# MQTT plugin for HomeVision - Ron Boston
# Parts borrowed from plug-ins written by Schelte Bron
# Version 1.0
# $Revision: 1.112 $
# $Date: 2022/08/04 15:46:02 $

hvImport debug
hvImport action
hvImport -name cnetio netio
hvImport -name cnetioaction netioaction

set version {$Id: hvmqtt.hap,v 1.112 2022/08/04 15:46:02 ron Exp $}
debug "$version" blue

tcl::tm::path add [file dirname [info script]]
set dir [file dirname [info script]]
set cfgfileroot [file tail [file rootnam [info script]]]

array set cfg {
    serPre "mqtt:"
    serPost ";"
    netioType "mqtt"
    geometry  ""
    sortTopic 0
    sortName  0
    sortX10   0
    broker     "localhost"
    brokerPort 1883
    userpass 0
    username ""
    password ""
    clientID ""
    cmndPrefix "cmnd"
    statPrefix "stat"
    telePrefix "tele"
    pwrPostfix "POWER"
    rstPostfix "RESULT"
    LWTPostfix "LWT"
    cycleTxt   ""
    publishQOS   1
    subscribeQOS 2
    x10Enable    1
    lightEnable  1
    varEnable    0
    flagEnable   0
    hvacEnable   0
    tempEnable   0
    analogEnable 0
    inputEnable  0
    outputEnable 0
    irEnable     0
    macroEnable  0
    seEnable     0
    peEnable     0
    timerEnable  0
    listWidths  {0 0 0}
    logging      0
    logpath      ""
    appResponseType   1
    otherResponseType 1
    pwrStatResponse   1
    rstStatResponse   0
    rstDimming        0
}
set cfg(txtext) [expr {$tcl_platform(platform) eq "windows" ? ".txt" : ""}]

set x10types {
    none  ""
    x10   "Standard X-10 Lamp Module"
    app   "Standard X-10 Appliance Module"
    ext   "X-10 Lamp Module with Direct Level Control"
    pcs   "Powerline Control Systems (PCS) Lamp Module"
    light "Custom Lights"
}

set objtypes {
    x10    {order 1 on on   off off   toggle toggle state state set on   clear off   setto on  cycle ""}
    light  {order 2 on on   off off   toggle toggle state state set on   clear off   setto on  cycle ""}
    flag   {order 3 on set  off clear toggle toggle state state set set  clear clear setto ""  cycle ""}
    var    {order 4 on on   off off   toggle toggle state state set set  clear ""    setto set cycle cycle}
    hvac   {order 5 on ""   off ""    toggle ""     state state set ""   clear ""    setto on  cycle ""}
    temp   {order 6 on ""   off ""    toggle ""     state state set ""   clear ""    setto ""  cycle ""}
    analog {order 7 on ""   off ""    toggle ""     state state set ""   clear ""    setto ""  cycle ""}
    input  {order 8 on ""   off ""    toggle ""     state state set ""   clear ""    setto ""  cycle ""}
    output {order 9 on high off low   toggle toggle state state set high clear low   setto ""  cycle ""     high high low low}
    ir     {order a on on   off ""    toggle ""     state state set ""   clear ""    setto on  cycle ""}
    macro  {order b on on   off ""    toggle ""     state state set ""   clear ""    setto ""  cycle "" run run}
    se     {order c on on   off ""    toggle ""     state state set ""   clear ""    setto ""  cycle "" run run}
    pe     {order d on on   off ""    toggle ""     state state set ""   clear ""    setto ""  cycle "" run run}
    timer  {order e on on   off ""    toggle ""     state state set ""   clear ""    setto ""  cycle "" start start stop stop clear clear load load}
}

set updtfp  {
    x10     0
    light   0
    flag    0
    var     0
    hvac    0
    temp    0
    analog  0
    input   0
    output  0
}

set connected  0
set mymqtt     ""
set logsuspend 0
set logmqtt 0
set noid 0
set nous 0
set yesretain 0
set nodevice 0

# define mqtt log command
if {[package require mqtt] >= 2} {
    mqtt log [list apply [list str {
        if {$::logmqtt == 0 && [regexp {PUBACK|SUBACK|PINGREQ|PINGRESP} $str]} {return}
        debug $str green
    }]]
} else {
    mqtt log {str} {
        debug $str green
    }
}

package require uuid 1.0.5

# Start MQTT Section

proc connect {} {
    global mymqtt cfg

    debug "connect" red
    if {[info exists mymqtt] && $mymqtt ne ""} {
        $mymqtt destroy
    }
    if {$cfg(userpass) && $cfg(username) ne "" && $cfg(password) ne ""} {
        set mymqtt [mqtt new -username $cfg(username) -password $cfg(password)]
    } else {
        set mymqtt [mqtt new]
    }
    $mymqtt connect $cfg(clientID) $cfg(broker) $cfg(brokerPort)
    $mymqtt subscribe {$SYS/local/connection} mqttStatusrecv
#    $mymqtt subscribe {$SYS/local/publication} mqttPublishrecv
}

hvImport mqttReady
proc mqttStatusrecv {topic payload retain} {

    mqttLog "mqttStatus:$payload;" red     
    mqttReady $payload
}

proc mqttPublishrecv {topic payload retain} {

    debug "mqttPublish:[dict get $payload topic],[dict get $payload data];" red     
}

proc disconnect {} {
    global mymqtt

    debug "BYE!" red
    if {[info exists mymqtt] && $mymqtt ne ""} {
        subscribe unsub
        $mymqtt disconnect
        mqttReady [dict create state disconnected reason 0]
    }
}

# topicTemplate - Decompose a fulltopic to its parts
#
# Use: topicTemplate $topic
#
# Returns a list containing a dict with the following key/values:
#   template {value}   One of <T>,>T<,<>T,T<>,><T,T><,<T,>T,T>,T<,T.
#   pre pos {value}    Prefix position 1-3, -1 if no prefix.
#   pre type {value}   Prefix string, "" if no prefix.
#   topic pos {value}  Sub-topic position 1-3.
#   topic name {value} Sub-topic string.
#   topic type {value} "s" (standard-contains both < and >), "ns" (non-standard) otherwise.
#   post pos {value}   Postfix position 1-3, -1 if no postfix.
#   post type {value}  Postfix string, "" if no postfix.
#   post ntype {value} Post type with "Relay" number striped off.
#   post index {value} "Relay" number or "[0-9]*" if none, or "" if no postfix.
#   match              Regexp expression to match the full topic.

hvPublic topicTemplate
proc topicTemplate {fulltopic} {
    global cfg

    set ft [split $fulltopic /]
    set ftlength [llength $ft]
    dict set layout template ""
    dict set layout pre pos -1
    dict set layout pre type ""
    dict set layout topic pos -1
    dict set layout topic name ""
    dict set layout topic type ""
    dict set layout post pos -1
    dict set layout post type ""
    dict set layout post ntype ""
    dict set layout post index ""
    dict set layout match ""

    foreach i {cmndPrefix statPrefix telePrefix} {
        set pr [lsearch -exact $ft $cfg($i)]
        if {$pr >= 0} {
            break
        }
    }
    foreach i [list "$cfg(pwrPostfix)\[0-9\]*" $cfg(rstPostfix) $cfg(LWTPostfix)] {
        set po [lsearch -regexp $ft $i]
        if {$po >= 0} {
            break
        }
    }

#debug "$pr,$po;" red
    if {$pr >= 0} {
        dict set layout pre type [lindex $ft $pr]
    } else {
        dict set layout pre type ""
    }
    if {$po >= 0} {
        dict set layout post type [lindex $ft $po]
        dict set layout post ntype [lindex $ft $po]
        set fmt [format {(%s)([0-9]*)$} $cfg(pwrPostfix)]
        if {[regexp $fmt [lindex $ft $po] --> resp index]} {
            dict set layout post index $index
            dict set layout post ntype $resp
        } else {
            dict set layout post index {[0-9]*}
        }
    } else {
        dict set layout post type ""
        dict set layout post ntype ""
        dict set layout post index ""
    }
    if {$pr < 0 && $po < 0} {
        dict set layout template "T"
        dict set layout topic name $fulltopic
        dict set layout topic type "ns"
        dict set layout topic pos 1
        dict set layout pre pos -1
        dict set layout post pos -1
        dict set layout match $fulltopic
    } else {
        if {$pr == 0} {
            if {$po == 1} {
                dict set layout template "<>T"
                dict set layout topic name [join [lrange $ft 2 end] /]
                dict set layout topic type "s"
                dict set layout topic pos 3
                dict set layout pre pos 1
                dict set layout post pos 2
                dict set layout match [format {^(<|%1$s/)(>%4$s|/%3$s)%2$s$} [lindex $ft $pr] [dict get $layout topic name] [lindex $ft $po] [dict get $layout post index ]]
            }
            if {$po ==  $ftlength-1} {
                dict set layout template "<T>"
                dict set layout topic name [join [lrange $ft 1 end-1] /]
                dict set layout topic type "s"
                dict set layout topic pos 2
                dict set layout pre pos 1
                dict set layout post pos 3
                dict set layout match [format {^(<|%1$s/)%2$s(>%4$s|/%3$s)$} [lindex $ft $pr] [dict get $layout topic name] [lindex $ft $po] [dict get $layout post index]]
            }
            if {$po == -1} {
                dict set layout template "<T"
                dict set layout topic name [join [lrange $ft 1 end] /]
                dict set layout topic type "ns"
                dict set layout topic pos 2
                dict set layout pre pos 1
                dict set layout post pos -1
                dict set layout match [format {^(<|%1$s/)%2$s$} [lindex $ft $pr] [dict get $layout topic name] [lindex $ft $po] [dict get $layout post index]]
            }
        }
        if {$po == 0} {
            if {$pr == 1} {
                dict set layout template "><T"
                dict set layout topic name [join [lrange $ft 2 end] /]
                dict set layout topic type "s"
                dict set layout topic pos 3
                dict set layout pre pos 2
                dict set layout post pos 1
                dict set layout match [format {^(>%4$s|%3$s/)(<|%1$s/)%2$s$} [lindex $ft $pr] [dict get $layout topic name] [lindex $ft $po] [dict get $layout post index]]
            }
            if {$pr ==  $ftlength-1} {
                dict set layout template ">T<"
                dict set layout topic name [join [lrange $ft 1 end-1] /]
                dict set layout topic type "s"
                dict set layout topic pos 2
                dict set layout pre pos 3
                dict set layout post pos 1
                dict set layout match [format {^(>%4$s|%3$s/)%2$s(<|/%1$s)$} [lindex $ft $pr] [dict get $layout topic name] [lindex $ft $po] [dict get $layout post index]]
            }
            if {$pr == -1} {
                dict set layout template ">T"
                dict set layout topic name [join [lrange $ft 1 end] /]
                dict set layout topic type "ns"
                dict set layout topic pos 2
                dict set layout pre pos -1
                dict set layout post pos 1
                dict set layout match [format {^(>%4$s|%3$s/)%2$s$} [lindex $ft $pr] [dict get $layout topic name] [lindex $ft $po] [dict get $layout post index]]
            }
        }
        if {$pr == $ftlength-1} {
            if {$po ==  $ftlength-2} {
                dict set layout template "T><"
                dict set layout topic name [join [lrange $ft 0 end-2] /]
                dict set layout topic type "s"
                dict set layout topic pos 1
                dict set layout pre pos 3
                dict set layout post pos 2
                dict set layout match [format {^%2$s(>%4$s|/%3$s)(<|/%1$s)$} [lindex $ft $pr] [dict get $layout topic name] [lindex $ft $po] [dict get $layout post index]]
            }
            if {$po == -1} {
                dict set layout template "T<"
                dict set layout topic name [join [lrange $ft 0 end-1] /]
                dict set layout topic type "ns"
                dict set layout topic pos 1
                dict set layout pre pos 2
                dict set layout post pos -1
                dict set layout match [format {^%2$s(<|/%1$s)$} [lindex $ft $pr] [dict get $layout topic name] [lindex $ft $po] [dict get $layout post index]]
            }
        }
        if {$po == $ftlength-1} {
            if {$pr ==  $ftlength-2} {
                dict set layout template "T<>"
                dict set layout topic name [join [lrange $ft 0 end-2] /]
                dict set layout topic type "s"
                dict set layout topic pos 1
                dict set layout pre pos 2
                dict set layout post pos 3
                dict set layout match [format {^%2$s(<|/%1$s)(>%4$s|/%3$s)$} [lindex $ft $pr] [dict get $layout topic name] [lindex $ft $po] [dict get $layout post index]]
            }
            if {$pr == -1} {
                dict set layout template "T>"
                dict set layout topic name [join [lrange $ft 0 end-1] /]
                dict set layout topic type "ns"
                dict set layout topic pos 1
                dict set layout pre pos -1
                dict set layout post pos 2
                dict set layout match [format {^%2$s(>%4$s|/%3$s)$} [lindex $ft $pr] [dict get $layout topic name] [lindex $ft $po] [dict get $layout post index]]
            }
        }
    }
#    debug $layout green
    return $layout
}

# build a full topic from a template
proc buildft {ftd} {
#debug "build: $ftd"
    if {[dict get $ftd pre pos] >= 0} {dict set ft [dict get $ftd pre pos] [dict get $ftd pre type]}
    if {[dict get $ftd post pos] >= 0} {dict set ft [dict get $ftd post pos] [dict get $ftd post type]}
    if {[dict get $ftd topic pos] >= 0} {dict set ft [dict get $ftd topic pos] [dict get $ftd topic name]}
    foreach i [lsort -integer [dict keys $ft]] {
        lappend res [dict get $ft $i]
    }
    return [join $res /]
}

# Read MQTT response
proc subrecv {topic msg {retain 0}} {
    global cfg objtypes

    set rst [topicTemplate $topic]
    debug "[dict get $rst template]: [buildft $rst]"
    set type [dict get $rst pre type]
    set device [dict get $rst topic name]
    set resp [dict get $rst post type]
    set nresp [dict get $rst post ntype]
    set match [dict get $rst match]
    set idx [dict get $rst post index]

    debug "Recv'd:[dict get $rst template],$type:$device:$resp,$nresp,$msg;$cfg(rstPostfix);" red
    switch $type \
        $cfg(statPrefix) - $cfg(telePrefix) {
            switch $nresp \
                $cfg(pwrPostfix) {
                    set payload [string tolower $msg]
#                   debug "$match; $resp: payload:$payload;" red
                    set row [mk::select cfg.devices -regexp topic $match]
                    if {$row ne ""} {
                        lassign [mk::get cfg.devices!$row flag macro_on macro_off varflag loglevel cmdtrig] id macro_on macro_off varflag loglevel cmdtrig
                        if {$loglevel & 0x01} {
                            mqttLog "rx: $topic $msg"
                        }
                        if {$payload eq {}} {
                            debug "No payload: $topic: $msg" red
                        } elseif {$payload eq "on"} {
                            mk::set cfg.devices!$row state "On" status 0
                            if {[triggers $row $topic $msg "on" 100] == 2} {return}
                            if {$id ne "" && $id < 512} {
                                if {$id < 256} {
                                    action flag set $id
                                    runMacro $macro_on
                                } elseif {$varflag & 0x01} {
                                    set id [expr {$id - 256}]
                                    action var set $id 1
                                    action var update
                                    runMacro $macro_on
                                }
                            } elseif {$id == 512} {
                                runMacro $macro_on
                            }
                        } elseif {$payload eq "off"} {
                            mk::set cfg.devices!$row state "Off" status 0
                            if {[triggers $row $topic $msg "off" 0] == 2} {return}
                            if {$id ne "" && $id < 512} {
                                if {$id < 256} {
                                    action flag clear $id
                                    runMacro $macro_off
                                } elseif {$varflag & 0x01} {
                                    set id [expr {$id - 256}]
                                    action var set $id 0
                                    action var update
                                    runMacro $macro_off
                                }
                            } elseif {$id == 512} {
                                runMacro $macro_off
                            }
                        } elseif {[string first $cfg(cycleTxt) $msg] != -1} {
                            mk::set cfg.devices!$row state [string range $cfg(cycleTxt) 0 2 ] status 0
                            if {$id ne "" && $id < 512} {
                            debug "id:$id;v:$varflag" darkred
                                if {$id > 255 && !($varflag & 0x01)} {
                                    set id [expr {$id - 256}]
                                    if {$varflag & 0x02} {
                                        if {[hvStateString var $id] == 255 && ![catch {hvObjectState var [expr {$id+1}]}]} {
                                            action var increment [expr {$id+1}]
                                        }
                                    }
                                    action var increment $id
                                    action var update
                                    runMacro $macro_on
                                }
                            }
                        } else {
                            lassign $payload st val
                            if {($st eq "on" && \
                                ([string is integer -strict $val] || [string is double -strict $val])) \
                             || ([string is integer -strict $st] || [string is double -strict $st])} {
                                if {$st ne "on"} {set val $st}
                                set val [expr {0xffff & int($val)}]
                                mk::set cfg.devices!$row state $val status 0
                                if {[triggers $row $topic $msg "on" $val] == 2} {return}
                                if {$id ne "" && $id < 512} {
                                    if {$id < 256} {
                                        if {$val & 0x01} {
                                            action flag set $id
                                            runMacro $macro_on
                                        } else {
                                            action flag clear $id
                                            runMacro $macro_off
                                        }
                                    } else {
                                        set id [expr {$id - 256}]
                                        if {$varflag & 0x01} {
                                            if {$val & 0x01} {
                                                action var set $id 1
                                                action var update
                                                runMacro $macro_on
                                            } else {
                                                action var set $id 0
                                                action var update
                                                runMacro $macro_off
                                            }
                                        } else {
                                            if {$varflag & 0x02 && ![catch {hvObjectState var [expr {$id+1}]}]} {
                                                action var set [expr {$id+1}] [expr {$val / 256}]
                                            }
                                            action var set $id [expr {$val % 256}]
                                            action var update
                                            runMacro $macro_on
                                        }
                                    }
                                } elseif {$id == 512} {
                                    runMacro $macro_on
                                }

                            } else {
                                mk::set cfg.devices!$row status 0
                            }
                        }
                        cfg_sortlist ext
                    }
                } $cfg(LWTPostfix) {
                    debug "LWT-$device:$msg" red
                    set row [mk::select cfg.devices -regexp topic $match]
                    if {$row ne ""} {
                        lassign [mk::get cfg.devices!$row loglevel] loglevel
                        if {$loglevel & 0x01} {
                            mqttLog "rx: $topic $msg"
                        }
                        set payload [string tolower $msg]
                        if {$payload eq "online"} {
                            mk::set cfg.devices!$row status 0
                        } elseif {$payload eq "offline"} {
                            mk::set cfg.devices!$row status 1
                        }
                        cfg_sortlist ext
                   }
                } default {
                    debug "Unknown response: $type, $resp" red
                }

        } $cfg(cmndPrefix) {
            switch $nresp \
                $cfg(pwrPostfix) {
                    set payload [string tolower $msg]
                    set r [mk::select cfg.x10 -regexp topic $match]
                    foreach row $r {
                        lassign [mk::get cfg.x10!$row id topic state level model object varflag loglevel retain] id dtopic state level model object varflag loglevel retain
                        if {$loglevel & 0x01} {
                            mqttLog "rx: $topic $msg"
                        }
                        set rcmd {}
                        if {$payload eq {} || $payload eq "?"} {
                            debug "No payload: $topic:$msg;" red
                            set objstat [getStatus $row]
                            debug "id:$id,object:$object;topic:$dtopic;objstat:$objstat" red
                            if {$object eq "timer"} {
                                set cmd [status_Timer $id]
                            } else {
                                set cmd [dict get $objstat cmd]
                            }
                            if {$cfg(pwrStatResponse)} {
                                sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                            }
                            if {$cfg(rstStatResponse)} {
                                set dim 1
                                if {$object eq "hvac" } {
                                    foreach k {Control HVAC Fan Temperature Setpoint} v $cmd {
                                        lappend rcmd $k $v
                                    }
                                } elseif {$object in {x10 light}} {
                                    if {$model eq "app"} {
                                        set dim 0
                                    }
                                    lappend rcmd $cfg(pwrPostfix)$idx $cmd
                                } elseif {$object eq "timer"} {
                                    set rcmd [list "STATE" [lindex $cmd 0] "TIME" [lrange $cmd 1 end]]
                                } else {
                                    lappend rcmd "STATE" $cmd
                                }
                                sendMqtt pub stat $dtopic rst [setResponse $rcmd $dim] [expr {($loglevel & 0x02)>>1}] $retain
                            }
                        } elseif {$object eq "hvac"} {
                            set cmd [lindex {Hold Run} [expr {$state & 0x01}]]
                            lappend cmd [lindex {Off Heat Cool Auto} [expr {($state & 0x06)>>1}]]
                            lappend cmd [lindex {Auto On} [expr {($state & 0x08)>>3}]]
                            lappend cmd $level
                            lappend cmd $model
                            foreach mode $payload {
                                if {[string is double -strict $mode]} {
                                    set temp [expr {int($mode)}]
                                    if {$temp >= 0 && $temp <= 99} {
                                        mk::set cfg.x10!$row model $temp
                                        set cmd [lreplace $cmd 4 4 $temp]
                                        action hvac setpoint [expr {$id-1}] $temp
                                    }
                                } elseif {$mode in {run hold}} {
                                    set cmd [lreplace $cmd 0 0 [string totitle $mode]]
                                    action hvac $mode [expr {$id-1}]
                                } elseif {$mode in {off cool heat auto}} {
                                    set cmd [lreplace $cmd 1 1 [string totitle $mode]]
                                    action hvac $mode [expr {$id-1}]
                                } elseif {$mode in {fanon fanauto}} {
                                    set cmd [lreplace $cmd 2 2 [string totitle [string range $mode 3 end]]]
                                    action hvac $mode [expr {$id-1}]
                                } else {
                                    continue
                                }
                            }
                            if {$cfg(pwrStatResponse)} {
                                sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                            }
                            if {$cfg(rstStatResponse)} {
                                foreach k {Control HVAC Fan Temperature Setpoint} v $cmd {
                                    lappend rcmd $k $v
                                }
                                sendMqtt pub stat $dtopic rst [setResponse $rcmd] [expr {($loglevel & 0x02)>>1}] $retain
                            }
                        } elseif {$payload in {on off toggle set clear low high run start stop clear}} {
                            if {[dict get $objtypes $object $payload] eq ""} {
                                debug "$object: $type, $resp, $payload not supported." red
                            } elseif {$object eq "var"} {
                                if {$payload in {on set}} {
                                    set val 1
                                } elseif {$payload in {off clear}} {
                                    set val 0
                                } elseif {$payload in {toggle}} {
                                    set val[hvStateString var $id]
                                    if {$val eq ""} {return}
                                    if {0x01 & $val} {
                                        set val 0
                                    } else {
                                        set val 1
                                    }
                                }
                                mk::set cfg.x10!$row level $val
                                if {$cfg(pwrStatResponse)} {
                                    sendMqtt pub stat $dtopic pwr $val [expr {($loglevel & 0x02)>>1}] $retain
                                }
                                if {$cfg(rstStatResponse)} {
                                    sendMqtt pub stat $dtopic rst [setResponse [list "STATE" $val]] [expr {($loglevel & 0x02)>>1}] $retain
                                }
                                if {$varflag & 0x02} {
                                    action var set [expr {$id+1}] 0
                                }
                                action var set $id $val
                                action var update
                            } elseif {$object eq "ir"} {
                                if {$payload ne "on"} {return}
                                set val 1
                                set cmd [setCmd $payload $val "other"]
                                if {$cfg(pwrStatResponse)} {
                                    sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] 0
                                }
                                if {$cfg(rstStatResponse)} {
                                    sendMqtt pub stat $dtopic rst [setResponse [list "STATE" $val]] [expr {($loglevel & 0x02)>>1}] 0
                                }
                                action ir transmit $id 1
                            } elseif {$object in {macro se pe}} {
                                if {$payload ni {on run}} {return}
                                set cmd "Unknown"
                                if {$cfg(pwrStatResponse)} {
                                    sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] 0
                                }
                                if {$cfg(rstStatResponse)} {
                                    sendMqtt pub stat $dtopic rst [setResponse [list "STATE" $cmd]] [expr {($loglevel & 0x02)>>1}] 0
                                }
                                action $object run $id
                            } elseif {$object in {timer}} {
                                if {$payload ni {start stop clear}} {return}
                                action $object $payload $id
                                set cmd [status_Timer $id]
                                if {$cfg(pwrStatResponse)} {
                                    sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] 0
                                }
                                if {$cfg(rstStatResponse)} {
                                    sendMqtt pub stat $dtopic rst [setResponse [list "STATE" [lindex $cmd 0] "TIME" [lrange $cmd 1 end]]] [expr {($loglevel & 0x02)>>1}] 0
                                }
                            } else {
                                if {$object eq "flag"} {
                                    if {$payload eq "toggle"} {
                                        set cmd [string map -nocase {Set Clear Clear Set} $state]
                                    } else {
                                        set cmd [string totitle [dict get $objtypes $object $payload]]
                                    }
                                    set newstate $cmd
                                    set newlevel "-"
                                    lappend rcmd "STATE" $cmd
                                    set dim 0
                                } elseif {$object in {output}} {
                                    set os [dict get $objtypes $object $payload]
                                    if {$payload eq "toggle"} {
                                        set cmd [hvObjectLabel $object $id 1]
                                        if {$cmd eq $state} {
                                            set cmd [hvObjectLabel $object $id 0]
                                        }
                                    } else {
                                        set cmd [hvObjectLabel $object $id [string map -nocase {high 1 low 0} $os]]
                                    }
                                    set newstate $cmd
                                    set newlevel "-"
                                    lappend rcmd "STATE" $cmd
                                    set dim 0
                                } elseif {$object in {x10 light}} {
                                    set dim 1
                                    set tmppay $payload
                                    if {$payload eq "toggle"} {
                                        set tmppay [string map -nocase {On off Off on} $state]
                                    }
                                    if {$tmppay eq "off"} {
                                        set newstate "Off"
                                        set newlevel 0
                                    } elseif {$tmppay eq "on"} {
                                        set newlevel 100
                                        set newstate "On"
                                    }
                                    if {$model eq "app"} {
                                        set dim 0
                                    }
                                    set cmd [setCmd $tmppay 100 $model]
                                    lappend rcmd $cfg(pwrPostfix)$idx $cmd
                                }
                                debug "id:$id,object:$object;newstate:$state;newlevel:$newlevel" red
                                if {$cmd eq ""} {return}
                                mk::set cfg.x10!$row state $newstate level $newlevel
                                if {$cfg(pwrStatResponse)} {
                                    sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                                }
                                if {$cfg(rstStatResponse)} {
                                    sendMqtt pub stat $dtopic rst [setResponse $rcmd $dim] [expr {($loglevel & 0x02)>>1}] $retain
                                }
                                action $object {*}[concat [dict get $objtypes $object $payload] $id]
                            }
                        } elseif {[string first $cfg(cycleTxt) $msg] != -1} {
                            if {$object eq "var" && !($varflag & 0x01)} {
                                set val [hvStateString var $id]
                                set msb [hvObjectState var [expr {$id+1}]]
                                if {$val eq "" || $msb eq ""} {return}
                                if {$varflag & 0x02} {
                                    if {$val == 255} {
                                        set cmd [expr {($msb+1)*256}]
                                        mk::set cfg.x10!$row level $cmd
                                        action var increment [expr {$id+1}]
                                    } else {
                                        set cmd [expr {($msb)*256 + ($val+1)%256}]
                                        mk::set cfg.x10!$row level $cmd
                                    }
                                } else {
                                    set cmd [expr {($val+1)%256}]
                                    mk::set cfg.x10!$row level $cmd
                                }
                                if {$cfg(pwrStatResponse)} {
                                    sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                                }
                                if {$cfg(rstStatResponse)} {
                                    sendMqtt pub stat $dtopic rst [setResponse [list "STATE" $cmd]] [expr {($loglevel & 0x02)>>1}] $retain
                                }
                                action var increment $id
                                action var update
                            }
                        } else {
                            lassign $payload st val
                            if {($st eq "on" && \
                                ([string is integer -strict $val] || [string is double -strict $val])) \
                             || ([string is integer -strict $st] || [string is double -strict $st])} {
                                if {$st ne "on"} {set val $st}
                                if {$object in {x10 light}} {
                                    set dim 1
                                    set val [expr {min(100, $val)}]
                                    switch $model {
                                        x10 {
                                            set arg [expr {round(16 * $val / 100.0)}]
                                            set level "level"
                                            set val [levelpercent $model $arg]
                                        }
                                        pcs {
                                            set arg [expr {round(floor(31 * $val / 100.0))}]
                                            set val [levelpercent $model $arg]
                                            set level "pcslevel"
                                        }
                                        ext {
                                            set arg [expr {round(63 * $val / 100.0)}]
                                            set level "directtolevel"
                                            set val [levelpercent $model $arg]
                                        }
                                        app {
                                            set arg ""
                                            set level "on"
                                            set val 100
                                            set dim 0
                                        }
                                        light {
                                            set arg [expr {round([hvLightConfigure maxlevel] * $val / 100.0)}]
                                            lappend arg 0
                                            set level "level"
                                        }
                                        default {
                                            set arg $val
                                            set level "level"
                                        }
                                    }
                                    set cmd [setCmd "on" $val $model]
                                    mk::set cfg.x10!$row state "On" level $val

                                    if {$cfg(pwrStatResponse)} {
                                        sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                                    }
                                    if {$cfg(rstStatResponse)} {
                                        sendMqtt pub stat $dtopic rst [setResponse [list $cfg(pwrPostfix)$idx $cmd] $dim] [expr {($loglevel & 0x02)>>1}] $retain
                                    }
                                    action $object {*}[concat $level $id $arg]
                                    action $object update
                                } elseif {$object eq "flag"} {
                                    if {0x01 & $val} {
                                        set cmd "Set"
                                    } else {
                                        set cmd "Clear"
                                    }
                                    mk::set cfg.x10!$row model $cmd
                                    if {$cfg(pwrStatResponse)} {
                                        sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                                    }
                                    if {$cfg(rstStatResponse)} {
                                        sendMqtt pub stat $dtopic rst [setResponse [list "STATE" $cmd]] [expr {($loglevel & 0x02)>>1}] $retain
                                    }
                                    action flag [string tolower $cmd] $id
                                } elseif {$object eq "ir"} {
                                    if {$val > 9} {set val 9}
                                    if {$val < 1} {set val 1}
                                    set cmd [setCmd "on" $val $model]
                                    if {$cfg(pwrStatResponse)} {
                                        sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] 0
                                    }
                                    if {$cfg(rstStatResponse)} {
                                        sendMqtt pub stat $dtopic rst [setResponse [list "STATE" $val]] [expr {($loglevel & 0x02)>>1}] 0
                                    }
                                    action ir transmit $id $val
                                } elseif {$object eq "var"} {
                                    set val [expr {0xffff & int($val)}]
                                    if {$varflag & 0x01} {
                                        if {0x01 & $val} {
                                            set val 1
                                        } else {
                                            set val 0
                                        }
                                        set cmd $val
                                        mk::set cfg.x10!$row level $val
                                    } else {
                                        if {$varflag & 0x02} {
                                            set cmd $val
                                            mk::set cfg.x10!$row level $cmd
                                            action var set [expr {$id+1}] [expr {$val / 256}]
                                            set val [expr {$val % 256}]
                                        } else {
                                            set cmd [expr {0xff & $val}]
                                            mk::set cfg.x10!$row level $cmd
                                        }
                                    }
                                    if {$cfg(pwrStatResponse)} {
                                        sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                                    }
                                    if {$cfg(rstStatResponse)} {
                                        sendMqtt pub stat $dtopic rst [setResponse [list "STATE" $cmd]] [expr {($loglevel & 0x02)>>1}] $retain
                                    }
                                    action var set $id [expr {0xff & $val}]
                                    action var update
                                }
                            } elseif {$st eq "load" && $object eq "timer"} {
                                set sval 1
                                action $object load $id {*}[lrange $payload 1 end]
                                set cmd [status_Timer $id]
                                if {$cfg(pwrStatResponse)} {
                                    sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] 0
                                }
                                if {$cfg(rstStatResponse)} {
                                    sendMqtt pub stat $dtopic rst [setResponse [list "STATE" [lindex $cmd 0] "TIME" [lrange $cmd 1 end]]] [expr {($loglevel & 0x02)>>1}] 0
                                }
                            }
                        }
                    }
                    cfg_sortlist obj
                } default {
                    debug "Unknown command: $type, $resp" red
                }
        } default {
            debug "Unknown prefix:$type" red
        }
}

proc runMacro {macro} {
    if {[string is integer -strict $macro] && $macro < 256} {
        action macro run $macro
    }
}

proc levelpercent {model arg} {
# Calculate level% based on level input
#  EXT     PCS     X10   STORED LEVEL   DISPLAYED %
#  arg     arg     arg       ta         return
#
# 62,63    31      16      10000         100
# 60,61    30              11111          96
# 58,59    29      15      01111          93
# 56,57    28              11110          90
# 54,55    27      14      01110          87
#
#  8,9      4       2      10010          15
#  6,7      3              00010          12
#  4,5      2       1      10001           9
#  2,3      1              00001           6
#  0,1      0       0      00000           0

    if {$model eq "x10"} {
        set arg [expr {$arg * 2}]
    } elseif {$model eq "ext"} {
        set arg [expr {$arg / 2}]
    }
    if {$arg == 0} {
        set ta 0
    } elseif {($arg == 31 && $model eq "pcs") || \
              ($arg == 32 && $model eq "x10")} {
        set ta 16
    } else {
        set ta [expr {($arg + 1)/2}]
        if {!($arg & 1)} {
            set ta [expr {$ta + 16}]
        }
    }
    set bStoredLevel [expr {($ta) & 31}]
    if {$bStoredLevel == 0} {return {0}}
    if {$bStoredLevel == 16} {return {100}}
    set bRegularLevel [expr {$bStoredLevel & 15}]
    set sTempResult [expr {$bRegularLevel * 2}]
    if {$bStoredLevel >= 16} {incr sTempResult}
    if {$model eq "x10"} {
        return [expr {int($sTempResult * 3.125)-3}]
    } else {
        return [expr {int($sTempResult * 3.125)}]
    }
}

# MQTT response for homevision topic
proc hvrecv {fulltopic msg {retain 0}} {
    global cfg objtypes

    set rst [topicTemplate $fulltopic]
    debug "[dict get $rst template]: [buildft $rst]"
    set topic [dict get $rst topic name]
    set resp [dict get $rst post type]

    debug "HV Recv'd: $topic, $resp, $msg" red
    if {$topic eq "homevision/action"} {
        if {[catch {hvExecTrigger $msg} rst]} {
            mqttComm pub $cfg(statPrefix)/$topic $rst
        } else {
            mqttComm pub $cfg(statPrefix)/$topic $msg
        }
        return
    }
    if {([string tolower $resp] ne "power") || $msg ni {"" ?}} {
        return
    }
    set ptopic [split $topic /]
    if {[llength $ptopic] == 1} {
        set objs [dict keys $objtypes]
    } elseif {[llength $ptopic] == 2} {
        set objs [string tolower [lindex $ptopic 1]]
        if {$objs ni [dict keys $objtypes]} {
            return
        }
    }
    # don't report on ir, se, pe, macro
    foreach ob {ir se pe macro} {
        set pos [lsearch -exact $objs $ob]
        set objs [lreplace $objs $pos $pos]
    }
    set match [join $objs |]
    if {$match eq ""} {
        return
    }
    foreach row [mk::select cfg.x10 -regexp object $match -sort object] {
        set objstat [getStatus $row]
        lassign [mk::get cfg.x10!$row id topic object loglevel retain model] id otopic object loglevel retain model
        if {$object eq "timer"} {
            set cmd [status_Timer $id]
        } else {
            set cmd [dict get $objstat cmd]
        }
        if {$cfg(pwrStatResponse)} {
            sendMqtt pub stat $otopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
        }
        if {$cfg(rstStatResponse)} {
            set dim 1
            set rcmd {}
            if {$object eq "hvac"} {
                foreach k {Control HVAC Fan Temperature Setpoint} v $cmd {
                    lappend rcmd $k $v
                }
            } elseif {$object in {x10 light}} {
                if {$model eq "app"} {set dim 0}
                if {![regexp {>([0-9]+)} $otopic --> idx]} {set idx ""}
                lappend rcmd $cfg(pwrPostfix)$idx $cmd
            } elseif {$object eq "timer"} {
                set rcmd [list "STATE" [lindex $cmd 0] "TIME" [lrange $cmd 1 end]]
            } else {
                lappend rcmd "STATE" $cmd
            }
            sendMqtt pub stat $otopic rst [setResponse $rcmd $dim] [expr {($loglevel & 0x02)>>1}] $retain
        }
    }
}

# MQTT response for custom triggered topics (standard triggered topics use subrecv)
proc trigrecv {topic msg {retain 0}} {

    debug "Trig Recv'd: $topic, $msg" red
    set row [mk::select cfg.devices -regexp topic $topic]
    if {$row ne ""} {
        triggers $row $topic $msg "" 0
    }
}

proc triggers {row topic msg state lvl} {

    lassign [mk::get cfg.devices!$row cmdtrig allonoff trigon trigoff trigstdcus] cmdtrig allonoff trigon trigoff trigstdcus
#    debug "triggers: $row,$state,$lvl;$cmdtrig,$allonoff,$trigstdcus,$trigon,$trigoff" red
    if {$cmdtrig != 2} {return $cmdtrig}
    set secs [clock seconds]
    set time [clock format $secs -format {%T}]
    set date [clock format $secs -format {%Y%m%d}]
    if {$trigstdcus == 0} {
        if {($allonoff == 0 || ($allonoff == 1 && $state == "on" && $lvl != 0)) \
             && $trigon ne ""} {
            set cmd $trigon
            debug "Triggering on:$cmd" darkgreen
        } elseif {$allonoff == 1 && ($state == "off" || ($state == "on" && $lvl == 0)) \
             && $trigoff ne ""} {
            set cmd $trigoff
            debug "Triggering off:$cmd" darkgreen
        } else {
            return $cmdtrig
        }
    } elseif {$trigon ne ""} {
        set cmd $trigon
        debug "Triggering Custom:$cmd" darkgreen
    } else {
        return $cmdtrig
    }
    set cmd [string map [list \
             %O $topic \
             %m [string map {\" '} $msg] \
             %M $msg \
             %L $lvl \
             %X [expr {round(floor(16 * $lvl / 100))}] \
             %P [expr {round(floor(31 * $lvl / 100))}] \
             %E [expr {round(floor(63 * $lvl / 100))}] \
             %T $time \
             %D $date \
             ] $cmd]
    hvExecTrigger $cmd
    return $cmdtrig
}

proc getStatus {row} {

    lassign [mk::get cfg.x10!$row id name topic state level model object varflag] id name topic state level model object varflag
    if {$id >= 256} {return}
    set cmd [hvStateString $object $id]
    lassign $cmd newstate newlevel
    set newsetp $model
    if {$object eq "hvac"} {
        lassign [hvObjectState $object $id] newstate newlevel newsetp
    } elseif {$object eq "var"} {
        if {!($varflag & 0x01) && ($varflag & 0x02) && ![catch {hvObjectState $object [expr {$id+1}]} msb]} {
            set cmd [expr {$msb*256 + $newstate}]
            set newlevel $cmd
        } else {
            set cmd $newstate
            set newlevel $newstate
        }
        set newstate "-"
    } elseif {$object in {temp analog}} {
        if {$newstate eq ""} {
            set newstate "Unknown"
        }
        set cmd $newstate
        set newlevel $newstate
        set newstate "-"
    } elseif {$object eq "flag"} {
        set cmd $newstate
        set newlevel "-"
    } elseif {$object in {input output}} {
        set os [hvObjectState $object $id]
        if {$os ne ""} {
            set newstate [hvObjectLabel $object $id $os]
        } else {
            set newstate "Unknown"
        }
        set cmd $newstate
        set newlevel "-"
    } elseif {$object in {ir macro se pe timer}} {
        set newstate "Unknown"
        set cmd "Unknown"
        set newlevel "-"
    } elseif {$object in {x10 light}} {
        set cmd [setCmd $newstate $newlevel $model]
    }
    return [dict create cmd $cmd newstate $newstate newlevel $newlevel newsetp $newsetp]
}

#  "app"  {0/2 {"on" 100      "off" 0} 1/3 {"on" "ON"        "off" "OFF"}}
#  other  {0/1 {"on" "$level" "off" 0} 2/3 {"on" "ON $level" "off" "OFF"}}
proc setCmd {state level model} {
    global cfg

    if {[string tolower $state] eq "off"} {
        if {$model eq "app"} {
            if {$cfg(appResponseType) == 0} {
                set cmd 0
            } else {
                set cmd "OFF"
            }
        } else {
            if {$cfg(otherResponseType) == 0} {
                set cmd 0
            } else {
                set cmd "OFF"
            }
        }
    } elseif {[string tolower $state] eq "on"} {
        if {$model eq "app"} {
            if {$cfg(appResponseType) == 0} {
                set cmd 100
            } else {
                set cmd "ON"
            }
        } else {
            if {$cfg(otherResponseType) == 0} {
                set cmd $level
            } else {
                set cmd "ON $level"
            }
        }
    } else {
        set cmd "Unknown"
    }
}

proc setResponse {keyval {dim 1}} {
    global cfg

#    debug "$keyval,$dim" green
    set i 0
    set result "\{"
    foreach {k v} $keyval {
        if {$i} {
            append result ","
        } else {
            set i 1
        }
        unset -nocomplain idx
        set fmt [format {(%s)([0-9]*)$} $cfg(pwrPostfix)]
        if {[regexp $fmt $k --> nk idx] && $cfg(rstDimming) && $dim} {
            if {![info exists idx]} {set idx ""}
            lassign $v a b
            if {$a eq "OFF" || $a == 0} {
                set a "OFF"
                set b 0
            } elseif {$a eq "ON"} {
                if {$b eq ""} {set b 100}
            } elseif {[string is integer -strict $a]} {
                set b $a
                set a "ON"
            } elseif {$b eq ""} {
                set b "Unknown"
            }
            append result "\"$cfg(pwrPostfix)$idx\":\"$a\",\"Dimmer\":$b"
        } else {
            if {$v eq ""} {
                set v "Unknown"
            }
            if {[string is integer -strict $v]} {
                append result "\"$k\":$v"
            } else {
                append result "\"$k\":\"$v\""
            }
        }
    }
    append result "\}"
    return $result
}
proc status_Timer {idx} {
    upd_Timers
    set ststr [hvStateString timer $idx]
    if {[string length $ststr]} {
        return $ststr
    } else {
        return "Unknown"
    }
}

#! Update Timer state information
proc upd_Timers {} {
    set data [hvSendCommand ,E03]
    foreach line [split $data \n] {
        if {![llength $line]} continue
        set rec ""
        foreach n [lrange $line 2 7] {
            lappend rec [scan $n %x]
        }
        set num [lindex $rec 1]
        hvObjectState timer $num [lreplace $rec 1 1]
    }
    hvLastUpdate timer 1
    return
}

proc devupdate {} {

    mk::loop row cfg.devices {
        sendCmd [mk::get $row name] ""
    }
}

proc objupdate {type {publish 1}} {
    global updtfp cfg

    debug "got $type update"
    if {![dict get $updtfp $type]} {
        # if first update, this was forced update;
        #   set flag and don't publish
        dict set updtfp $type 1
        set publish 0
    }
    foreach row [mk::select cfg.x10 -regexp object $type] {
        lassign [mk::get cfg.x10!$row id name topic state level model object varflag loglevel retain] id name topic state level model object varflag loglevel retain
        set objstat [getStatus $row]
        dict with objstat {
           if {$newstate ne $state || $newlevel ne $level || $newsetp ne $model} {
                mk::set cfg.x10!$row state $newstate level $newlevel model $newsetp
                 debug "$object:$id-$topic!:$state->$newstate,$level->$newlevel,$model->$newsetp;cmd:$cmd"
                if {$publish} {
                    if {$cfg(pwrStatResponse)} {
                        sendMqtt pub stat $topic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                    }
                    if {$cfg(rstStatResponse)} {
                        set rcmd {}
                        if {$object eq "hvac"} {
                            foreach k {Control HVAC Fan Temperature Setpoint} v $cmd {
                                lappend rcmd $k $v
                            }
                        } elseif {$object in {x10 light}} {
                                if {![regexp {>([0-9]+)} $topic --> idx]} {set idx ""}
                                lappend rcmd $cfg(pwrPostfix)$idx $cmd
                        } else {
                                lappend rcmd "STATE" $cmd
                        }
                        sendMqtt pub stat $topic rst [setResponse $rcmd] [expr {($loglevel & 0x02)>>1}] $retain
                    }
                }
            }
        }
    }
    cfg_sortlist obj
}

proc subscribe {{type sub}} {

    if {$type ni {sub unsub}} {return}

    mk::loop row cfg.devices {
        lassign [mk::get $row topic cmnd lwt cmdtrig trigstdcus] topic cmnd lwt cmdtrig trigstdcus
        if {$topic ne ""} {
            set cmnd [customCmnd $cmnd $cmdtrig $trigstdcus]
            if {$lwt ne "" && $lwt \
                && [regexp {<} $topic] && [regexp {>[0-9]*} $topic]} {
                # subscribe to lwt only if standard topic and lwt flag set
                sendMqtt $type tele $topic LWT $cmnd
            }
            sendMqtt $type stat $topic pwr $cmnd
        }
    }
    mk::loop row cfg.x10 {
        set topic [mk::get $row topic]
        if {$topic ne ""} {
            sendMqtt $type cmnd $topic pwr subrecv
        }
    }
    sendMqtt $type cmnd "<homevision/#" "" hvrecv
}

# Determine callback
proc customCmnd {cmnd cmdtrig trigstdcus} {

    if {$cmnd ne "" && $cmdtrig == 1} {
        hvImport -name Custom_$cmnd $cmnd
        return Custom_$cmnd
    } elseif {$cmnd ne "" && $cmdtrig == 2 && $trigstdcus == 1} {
        return "trigrecv"
    } else {
        return "subrecv"
    }
}

# Send command
proc sendCmd {name cmd} {

    set retain 0
    if {$name in {pub}} {
        set cmd [join [lassign $cmd topic]]
        set topic [string trim $topic {\}\{}]
        if {[lindex $cmd end] eq "retain"} {
            set cmd [lrange $cmd 0 end-1]
            set retain 1
        }
        set log 1
    } elseif {$name in {sub unsub}} {
        set cb [lassign $cmd topic]
        set topic [string trim $topic {\}\{}]
        set cb [lindex $cb 0]
        if {$cb ne ""} {
            hvImport -name Custom_$cb $cb
            set cmd Custom_$cb
        } else {
            set cmd "subrecv"
        }
        set log 0
    } else {
        foreach device {"devices" "x10"} {
            set row [mk::select cfg.$device name $name]
            if {$row ne ""} {break}
        }
        if {$row eq ""} {return}
        lassign [mk::get cfg.$device!$row topic loglevel retain] topic loglevel retain
        set name "pub"
        set log [expr {($loglevel & 0x02)>>1}]
    }
    sendMqtt $name cmnd $topic pwr $cmd $log $retain
}

# Create command to send
proc createCmd {cmd} {
    if {[string tolower $cmd] in {1 "on"}} {
        set state "on"
    } elseif {[string tolower $cmd] in {0 "off"}} {
        set state "off"
    } elseif {[string tolower $cmd] in {2 "toggle"}} {
        set state "toggle"
    } elseif {[string tolower $cmd] in {"state"}} {
        set state ""
    } else {
        set state $cmd
    }
    return $state
}

proc sendMqtt {action pre topic post cmd args} {
    global cfg mymqtt

    if {![info exists mymqtt] || $mymqtt eq ""} {return}
    lassign $args log retain
    if {$log eq "" } {set log 0}
    if {$retain eq ""} {set retain 0}
    set npre [expr {[info exists cfg(${pre}Prefix)]?$cfg(${pre}Prefix):$pre}]
    set npost [expr {[info exists cfg(${post}Postfix)]?$cfg(${post}Postfix):$post}]
    if {$npost eq "$cfg(pwrPostfix)"} {
        append npost "\\2"
    }
    regsub {<} $topic "/$npre/" topic
    regsub {(>)([0-9]*)} $topic "/$npost/" topic
    set topic [regsub {//+} [string trim $topic {/}] {/}]

    switch $action {
        pub {
            if {[catch {$mymqtt publish $topic $cmd $cfg(publishQOS) $retain} rc]} {
                debug "Publish failed: $topic, $cmd: $rc" red
            } else {
                debug "Published $topic, $cmd!"
            }
        }
        sub {
            $mymqtt subscribe $topic $cmd $cfg(subscribeQOS)
            debug "Subscribed to $topic, $cmd!"
        }
        unsub {
            $mymqtt unsubscribe $topic $cmd
            debug "Unsubscribed from $topic, $cmd!"
        }
    }
    if {$log} {
        mqttLog "tx: $topic $cmd"
    }
}

proc createObjects {} {
    global discovDevices

    set type [.mqtt.f.f4.c1 get]
    set win .mqtt.f.f4.ni.f.tv
    if {$type eq "All" || $type eq ""} {
        $win delete [$win children {}]
        $win state disabled
        return
    } else {
        $win state readonly
    }
    if {$type eq "flag_b"} {
        set match "flag"
    } elseif {$type eq "var_n"} {
        set match "var"
    } else {
        set match $type
    }

    $win delete [$win children {}]
    $win insert {} end -values [list 999 "-" "All"]

    if {$type in [dict keys $discovDevices]} {
        dict for {id info} [dict get $discovDevices $type] {
            set values [list $id [lindex $info 0] [lindex $info 1]]
            $win insert {} end -values $values
        }
    } else {
        set rows [mk::select cfg.x10 -regexp object $match -sort id]
        if {![llength $rows]} {
            return
        }
        foreach row $rows {
            lassign [mk::get cfg.x10!$row id object state name] id object state name
            set values [format {%3d} $id]
            if {$object eq "x10"} {
                lappend values [string map {" " -} [hvObjectId x10 $id]]
            } elseif {$object in {input output}} {
                lappend values [string toupper [string index $object 0]][hvObjectId $object $id]
            } else {
                lappend values "[string toupper [string range $object 0 1]]-$id"
            }
            lappend values $name
#            debug "values:$values" green
            lappend allvalues $values
        }
        set allvalues [lsort -integer -index 0 $allvalues]
        foreach values $allvalues {
            $win insert {} end -values $values
        }
    }
}

hvImport getDiscovDevices
proc createList {} {
    global discovDevices objtypes

    set values {All}
    foreach obs [dict keys $objtypes] {
        if {[hvObjectCount $obs] > 0} {
            lappend values $obs
            if {$obs eq "flag"} {
                lappend values "flag_b"
            } elseif {$obs eq "var"} {
                lappend values "var_n"
            }
        }
    }

    set discovDevices [getDiscovDevices]
    set tmp {}
    for {set i 0} {$i < [llength $discovDevices]} {incr i} {
        dict set tmp {*}[lindex $discovDevices $i]
    }
    set discovDevices $tmp
    foreach obs [dict keys $discovDevices] {
        lappend values $obs
    }
    return $values
}

hvPublic getDiscovConfig
proc getDiscovConfig {} {
    global cfg

    return [list clientID $cfg(clientID) \
        cmndPrefix  $cfg(cmndPrefix) \
        statPrefix  $cfg(statPrefix) \
        telePrefix  $cfg(telePrefix) \
        pwrPostfix  $cfg(pwrPostfix) \
        rstPostfix  $cfg(rstPostfix) \
        LWTPostfix  $cfg(LWTPostfix) \
    ]
}

proc runDiscovery {} {
    global noid nous yesretain nodevice

    set type [.mqtt.f.f4.c1 get]
    set win .mqtt.f.f4.ni.f.tv

    set opts {}
    if {$noid == 1} {
        lappend opts "-noid"
    }
    if {$nous == 1} {
        lappend opts "-nous"
    }
    if {$yesretain == 1} {
        lappend opts "-retain"
    }
    if {$nodevice == 1} {
        lappend opts "-nodevice"
    }
    set mode [.mqtt.f.f4.c3 get]
    if {$mode eq "Discover"} {
        lappend opts 1
    } elseif {$mode eq "UnDiscover"} {
        lappend opts 0
    } else {
        lappend opts 3
    }
    if {$type eq "" || $type eq "All"} {
    } else {
        lappend opts $type
    }
    set chosen [$win selection]
    foreach item $chosen {
        lassign [$win item $item -values] nid id name
        if {$nid != 999} {
            lappend opts $nid

        }
    }
    my_haObjectDiscovery {*}$opts
}

hvImport -name my_haObjectDiscovery haObjectDiscovery
hvPublic haObjectDiscovery
proc haObjectDiscovery {args} {
    global cfg

    debug "HA Discovery:$args;"
    set ids ""
    set noid 0
    set nous 0
    set retain 0
    set nodevice 0
    while 1 {
        if {[lindex $args 0] eq "-noid"} {
            set noid 1
            set args [lrange $args 1 end]
            continue
        }
        if {[lindex $args 0] eq "-nous"} {
            set nous 1
            set args [lrange $args 1 end]
            continue
        }
        if {[lindex $args 0] eq "-retain"} {
            set retain 1
            set args [lrange $args 1 end]
            continue
        }
        if {[lindex $args 0] eq "-nodevice"} {
            set nodevice 1
            set args [lrange $args 1 end]
            continue
        }
        break
    }
    set altmatch ""
    set altobj 0
    set args [lassign $args add]
    set obs [createList]
    if {$args eq ""} {
        set match [join $obs |]
    } else {
        set ids [lassign $args otype]
        set match [string tolower $otype]
        if {$match eq "flag_b"} {
            set altmatch $match
            set match "flag"
            set altobj 1
        } elseif {$match eq "var_n"} {
            set altmatch $match
            set match "var"
            set altobj 1
        } elseif {$match ni $obs} {
            return
        }
    }
    debug "Objects: $match, ids:$ids;" red
    foreach row [mk::select cfg.x10 -regexp object $match -sort object] {
        lassign [mk::get cfg.x10!$row id name topic type object model] id name topic type object model
        if {$ids eq "" || $id in $ids} {
            sendDiscovery $noid $nous $retain $nodevice $add $id $name $topic [expr {$altobj == 1 ? $altmatch : $object}] $model HomeVision
            if {$object eq "timer"} {
            sendDiscovery $noid $nous $retain $nodevice $add $id $name $topic "timer_t" $model HomeVision
            }
        }
    }
}

#hvPublic sendDiscovery
proc sendDiscovery {noid nous retain nodevice add id name topic object type  model {man "CustomSolutions"}} {
    global cfg

    if {$object eq "x10"} {
        set fid [string map {" " -} [hvObjectId x10 $id]]
    } elseif {$object in {input output}} {
        set fid [string toupper [string index $object 0]][hvObjectId $object $id]
    } else {
        set fid "[string toupper [string range $object 0 1]]-$id"
    }
    
    set objsuffix [string totitle $object]

    if {$object eq "flag_b"} {
        append fid "b"
    }
    if {$object eq "var_n"} {
        append fid "n"
    }
    if {$object eq "timer_t"} {
        append name "_time"
        append fid "t"
        set objsuffix [string totitle "timer"]
    }
    if {$object eq "timer"} {
        append name "_state"
    }
    
    set uid $cfg(clientID)_$fid

    regsub {<} $topic "/$cfg(statPrefix)/" stat
    regsub {>} $stat "/RESULT/" stat
    set stat [regsub {//+} [string trim $stat {/}] {/}]
    regsub {<} $topic "/$cfg(cmndPrefix)/" cmnd
    regsub {>} $cmnd "/$cfg(pwrPostfix)/" cmnd
    set cmnd [regsub {//+} [string trim $cmnd {/}] {/}]

    set discov {}
    debug "$fid, $uid, $topic, $cmnd, $stat;"

    dict set discov uniq_id $uid

    if {$nous == 1} {
        set name [string map {_ " "} $name]
    }
    if {$noid == 1} {
        dict set discov name "$name"
    } else {
        dict set discov name "[string map {_ "-"} $fid] $name"
    }
    dict set discov ret false
    if {$retain == 1} {
        dict set discov ret true
    }
    dict set discov qos 1
    if {$nodevice == 0} {
        dict set discov dev [format {{"ids":["%s"],"name":"%s","mdl":"%s","mf":"%s"}} "$cfg(clientID)_$objsuffix" "HomeVisionXL $objsuffix" $model $man]
    }
    
    switch $object {
        x10 -
        light {
            dict set discov "~" "$stat"
            dict set discov stat_t "~"
            dict set discov cmd_t "$cmnd"
            dict set discov pl_on "ON"
            dict set discov pl_off "OFF"
            if {$type in {app switch}} {
                set device "switch"
                dict set discov val_tpl "{{ value_json.$cfg(pwrPostfix) }}"
            } else {
                set device "light"
                dict set discov stat_val_tpl "{{ value_json.$cfg(pwrPostfix) }}"
                dict set discov bri_cmd_t "$cmnd"
                dict set discov bri_stat_t "~"
                dict set discov bri_scl 100
                dict set discov bri_val_tpl "{{ value_json.Dimmer }}"
                dict set discov on_cmd_type "brightness"
            }
        }
        flag {
            set device "switch"
            dict set discov stat_t "$stat"
            dict set discov val_tpl "{{ value_json.STATE }}"
            dict set discov cmd_t "$cmnd"
            dict set discov pl_on "Set"
            dict set discov pl_off "Clear"
            dict set discov stat_on "Set"
            dict set discov stat_off "Clear"
        }
        flag_b {
            set device "binary_sensor"
            dict set discov stat_t "$stat"
            dict set discov val_tpl "{{ value_json.STATE }}"
            dict set discov pl_on "Set"
            dict set discov pl_off "Clear"
            dict unset discov ret
            if {[regexp {dc:(\w+)} [hvObjectDesc flag $id] --> dc]} {
                if {$dc ne ""} {
                    dict set discov dev_cla $dc
                }
            }
        }
        output {
            set device "switch"
            dict set discov stat_t "$stat"
            dict set discov val_tpl "{{ value_json.STATE }}"
            dict set discov cmd_t "$cmnd"
            dict set discov pl_on "high"
            dict set discov pl_off "low"
            dict set discov stat_on "[hvObjectLabel $object $id 1]"
            dict set discov stat_off "[hvObjectLabel $object $id 0]"
        }
        ir {
            set device "switch"
            dict set discov stat_t "$stat"
            dict set discov val_tpl "{{ value_json.STATE }}"
            dict set discov cmd_t "$cmnd"
            dict set discov pl_on "ON 1"
            dict set discov pl_off "Off 1"
            dict set discov stat_on "ON"
            dict set discov stat_off "Unknown"
        }
        macro -
        se -
        pe {
            set device "switch"
            dict set discov stat_t "$stat"
            dict set discov val_tpl "{{ value_json.STATE }}"
            dict set discov cmd_t "$cmnd"
            dict set discov pl_on "Run"
            dict set discov pl_off "Off"
            dict set discov stat_on "ON"
            dict set discov stat_off "Unknown"
        }
        var {
            set device "sensor"
            dict set discov stat_t "$stat"
            dict set discov val_tpl "{{ value_json.STATE }}"
            dict unset discov ret
            if {[regexp {dc:(\w+)} [hvObjectDesc $object $id] --> dc]} {
                if {$dc ne ""} {
                    dict set discov dev_cla $dc
                }
            }
        }
        var_n {
            set device "number"
            dict set discov stat_t "$stat"
            dict set discov val_tpl "{{ value_json.STATE }}"
            dict set discov cmd_t "$cmnd"
            dict set discov max 255
            if {[regexp {max:(\d+)} [hvObjectDesc var $id] --> max]} {
                if {$max ne ""} {
                    dict set discov max $max
                }
            }
            dict set discov min 0
            if {[regexp {min:(\d+)} [hvObjectDesc var $id] --> min]} {
                if {$min ne ""} {
                    dict set discov min $min
                }
            }
            if {[regexp {dc:(\w+)} [hvObjectDesc var $id] --> dc]} {
                if {$dc ne ""} {
                    dict set discov dev_cla $dc
                }
            }
        }
        timer {
            set device "sensor"
            dict set discov stat_t "$stat"
            dict set discov val_tpl "{{ value_json.STATE }}"
            dict unset discov ret
            if {[regexp {dc:(\w+)} [hvObjectDesc $object $id] --> dc]} {
                if {$dc ne ""} {
                    dict set discov dev_cla $dc
                }
            }
        }
        timer_t {
            set device "sensor"
            dict set discov stat_t "$stat"
            dict set discov val_tpl "{{ value_json.TIME }}"
            dict unset discov ret
            if {[regexp {dc:(\w+)} [hvObjectDesc timer $id] --> dc]} {
                if {$dc ne ""} {
                    dict set discov dev_cla $dc
                }
            }
        }
        analog {
            set device "sensor"
            dict set discov stat_t "$stat"
            dict set discov val_tpl "{{ value_json.STATE }}"
            dict unset discov ret
            if {[regexp {dc:(\w+)} [hvObjectDesc $object $id] --> dc]} {
                if {$dc ne ""} {
                    dict set discov dev_cla $dc
                }
            }
        }
        temp {
            set device "sensor"
            dict set discov stat_t "$stat"
            dict set discov val_tpl "{{ value_json.STATE }}"
            dict unset discov ret
            dict set discov dev_cla "temperature"
            if {[hvVariable TempScale] eq -1} {
                dict set discov unit_of_meas "C"
            } else {
                dict set discov unit_of_meas "F"
            }
            if {[regexp {dc:(\w+)([\-F|\-f|\-C|\-c]*)} [hvObjectDesc $object $id] --> dc uom]} {
                if {$dc ne ""} {
                    dict set discov dev_cla $dc
                    set uom [string index $uom 1]
                    if {$uom in {F f C c}} {
                        dict set discov unit_of_meas [string toupper $uom]
                    }
                }
            }
        }
        input {
            set device "binary_sensor"
            dict set discov stat_t "$stat"
            dict set discov val_tpl "{{ value_json.STATE }}"
            dict set discov pl_on "[hvObjectLabel $object $id 0]"
            dict set discov pl_off "[hvObjectLabel $object $id 1]"
            dict unset discov ret
            if {[regexp {dc:(\w+)} [hvObjectDesc $object $id] --> dc]} {
                if {$dc ne ""} {
                    dict set discov dev_cla $dc
                }
            }
        }
        hvac {
            set preset 1
            set device "climate"
            dict set discov modes {["auto", "off", "cool", "heat"]}
            dict set discov fan_modes {["fanauto","fanon"]}
            dict set discov mode_cmd_t "$cmnd"
            dict set discov temp_cmd_t "$cmnd"
            dict set discov fan_mode_cmd_t "$cmnd"
            dict set discov "~" "$stat"
            dict set discov curr_temp_t "~"
            dict set discov curr_temp_tpl "{{ value_json.Temperature }}"   
            dict set discov mode_stat_t "~"
            dict set discov mode_stat_tpl "{{ value_json.HVAC|lower }}"   
            if {$preset == 1} {
                dict set discov pr_modes {["run","hold"]}
                dict set discov pr_mode_cmd_t "$cmnd"
                dict set discov pr_mode_stat_t "~"
                dict set discov pr_mode_val_tpl "{{ value_json.Control|lower }}"   
            } else {
                dict set discov hold_modes {["run","hold"]}
                dict set discov hold_cmd_t "$cmnd"
                dict set discov hold_stat_t "~"
                dict set discov hold_stat_tpl "{{ value_json.Control|lower }}"   
            }
            dict set discov temp_stat_t "~"
            dict set discov temp_stat_tpl "{{ value_json.Setpoint }}"   
            dict set discov fan_mode_stat_t "~"
            dict set discov fan_mode_stat_tpl "{{ \\\"fan\\\" + value_json.Fan|lower }}"   
            dict set discov temp_unit "F"
            dict set discov precision 1.0
            dict set discov max_temp 99
            dict set discov min_temp 55
           if {$nodevice == 0} {
                dict set discov dev [format {{"ids":["%s"],"name":"%s","mdl":"TX-15","mf":"RCS"}} "$cfg(clientID)_$objsuffix" "HomeVisionXL $objsuffix"]
            }
        }
        default {
            return
        }
    }

    foreach key [dict keys $discov] {
        switch $key {
            bri_scale -
            max_temp -
            min_temp -
            max -
            min -
            qos {
                set fmt {"%s":%d}
            }
            ret -
            dev -
            precision -
            modes -
            fan_modes -
            pr_modes -
            hold_modes {
                set fmt {"%s":%s}
            }
            default {
                 set fmt {"%s":"%s"}
            }
        }
        lappend jl [format $fmt $key [dict get $discov $key]]
    }
    append js "{" [join $jl ","] "}"
    
    set fulltopic "homeassistant/$device/$uid/config"
    debug $fulltopic darkblue
    debug $js blue
    if {$add == 0} {
        set js ""
    }
    if {$add == 0 || $add == 1} {
        sendMqtt pub cmnd $fulltopic pwr $js 0 1
    }
}

#! Write MQTT status information to log file
hvPublic mqttLog
proc mqttLog {str {color red}} {
    global loghandle mqttlogdate cfg logsuspend dir

    if {!$cfg(logging) || $logsuspend == 2} return
    set time [clock seconds]
    set date [clock format $time -format %y%m%d]
    if {![info exists loghandle] || $date ne $mqttlogdate} {
        if {[info exists loghandle]} {
            catch {close $loghandle}
        }
        set t 0
        foreach logpath [list $cfg(logpath) [file join $dir log]] {
            if {[catch {file mkdir $logpath}]} {
                debug "Failed to access MQTT log directory,$logpath" red
                incr t
                continue
            }
            set file [file join $logpath MQTTLog$date$cfg(txtext)]
            if {[catch {open $file a} loghandle]} {
                unset loghandle
                debug "Failed to open MQTT log file,$file" red
                incr t
                continue
            }
            set mqttlogdate $date
            break
        }
        set logsuspend $t
        if {$t >= 2} {
            debug "Suspend logging for 5 mins" red
            after 300000 restorelogging
            return 0
        }
    } elseif {[info exists loghandle] && $logsuspend == 1} {
        #retry orig logpath
        set logpath $cfg(logpath)
        if {[catch {file mkdir $logpath}]} {
            # Failed orig logpath, keep alternate
        } else {
            # Found orig, try a file
            set file [file join $logpath MQTTLog$date$cfg(txtext)]
            if {[catch {open $file a} lh]} {
                # Failed orig log file, keep alternate
                unset lh
                debug "Failed to open MQTT log file,$file" red
            } else {
                debug "Reopened original log file,$file" blue
                if {[info exists loghandle]} {
                    catch {close $loghandle}
                }
                set loghandle $lh
                set logsuspend 0
                set mqttlogdate $date
            }
        }
    }
    debug $str $color
    catch {puts -nonewline $loghandle "[clock format $time -format "%d.%m.%Y %H.%M.%S"]\t$str\n"}
    catch {flush $loghandle}
    return 1
}

proc restorelogging {} {
    global logsuspend
    #after timeout, try again to log next time.
    set logsuspend 0
}

# End MQTT Section

# Start Trigger section

# mqttComm is called by other plugins to communicate with MQTT.
#
#    mqttComm {type} {options} action topic {payload}
#
# Examples:
#    mqttComm {-log} sub|unsub  <topic>|topic callback 
#    mqttComm {-exactstat -nodim -log -retain} stat|cmnd <topic>|topic {payload}
#    mqttComm {-log -retain} pub <i>topic</i> {payload}
#
# "type" is the name calling plugin's id. (Deprecated.)
# -log: log this command to MQTT log.
# -retain: retain this message.
# -exactstat: Sends a pwr stat regardless of power/result settings.
# -nodim: Don't include Dimmming in RESULT response
# "action" is "sub"   - subscribe this topic
#             "unsub" - unsubscribe this topic
#             "stat"  - send status for topic/payload
#             "cmnd"  - send cmnd for topic/payload
#             "pub"   - send cmnd for topic/payload
# "topic" should be enclosed in "<>" to use MQTT's
#         standard pre- and post-fixes
hvPublic mqttcomm
proc mqttcomm {args} {
# for backward compatibility
    mqttComm {*}$args
}
hvPublic mqttComm
proc mqttComm {args} {
    global cfg mymqtt

#    debug "mqttComm: $args" red
    if {![info exists mymqtt] || $mymqtt eq ""} {return ""}
    set log 0
    set retain 0
    set exactstat 0
    set dim 1
    set nargs $args
    if {[lindex $nargs 0] ni {sub unsub cmnd stat pub -log -retain -exactstat -nodim}} {
        set nargs [lrange $args 1 end]
    }
    while 1 {
        if {[lindex $nargs 0] eq "-log"} {
            set log 1
            set nargs [lrange $nargs 1 end]
            continue
        }
        if {[lindex $nargs 0] eq "-retain"} {
            set retain 1
            set nargs [lrange $nargs 1 end]
            continue
        }
        if {[lindex $nargs 0] eq "-exactstat"} {
            set exactstat 1
            set nargs [lrange $nargs 1 end]
            continue
        }
        if {[lindex $nargs 0] eq "-nodim"} {
            set dim 0
            set nargs [lrange $nargs 1 end]
            continue
        }
        break
    }
    set cb_pl [lassign $nargs action topic]

    if {$action eq "" || $topic eq ""} {return 0}
    if {$action eq "sub"} {
        lassign $cb_pl cb
        if {$cb eq "" } {return 0}
        hvImport -name Custom_$cb $cb
        sendMqtt sub cmnd $topic pwr Custom_$cb
    } elseif {$action eq "unsub"} {
        lassign $cb_pl cb
        if {$cb eq "" } {return 0}
        sendMqtt unsub cmnd $topic pwr Custom_$cb
    } elseif {$action eq "stat"} {
        if {$cb_pl eq ""} {return 0}
        if {$exactstat || $cfg(pwrStatResponse)} {
            sendMqtt pub stat $topic pwr [join $cb_pl] $log $retain
        }
        if {!$exactstat && $cfg(rstStatResponse)} {
            sendMqtt pub stat $topic rst [setResponse [list $cfg(pwrPostfix) [join $cb_pl]] $dim] $log $retain
        }
    } elseif {$action in {cmnd pub}} {
        sendMqtt pub cmnd $topic pwr [join $cb_pl] $log $retain
    } else {
        return 0
    }
    return 1
}

# netioaction is called by NetIO "netioaction" command.
# Example: sends: netioaction mqtt devicename [0|off|1|on|2|toggle]
#          sends: netioaction mqtt pub topic payload [retain]
#          sends: netioaction mqtt [sub|unsub] topic;
# "mqtt" must match config's netioType.
# "device name" must match an allowed device name.
# For "pub": if payload ends in "retain", published message's retain flag is set.
hvPublic netioaction
proc netioaction {args} {
    global cfg

    set state [lassign $args type name]
    if {$type ne $cfg(netioType)} {return ""}
    if {$state eq ""} {return ""}
    sendCmd $name [createCmd $state]
}

# netio is called by NetIO "get" command.
# Example: reads: get mqtt name
# "mqtt" must match config's netioType.
# "name" must match an allowed device name.
# Note: For external devices,
#       returns state of the flag or variable value associated with the device,
#       not the actual current state.
#       For X10/Custom Light, returns On/Off.
#         Use standard x10 Netio gets for better control.
hvPublic netio
proc netio {args} {
    global cfg
debug "netio:$args" blue
    lassign $args type name
    if {$type ne $cfg(netioType)} {return ""}

    foreach device {"devices" "x10"} {
        set row [mk::select cfg.$device name $name]
        if {$row ne ""} {break}
    }
    if {$row eq ""} {return ""}

    if {$device eq "devices"} {
        set flag [mk::get cfg.devices!$row flag]
        if {$flag >= 512 || $flag eq ""} {return ""}
        if {$flag > 255} {
            set flag [expr {$flag - 256}]
            return [hvObjectState var $flag]
        } else {
            return [hvObjectState flag $flag]
        }
    } else {
        lassign [mk::get cfg.x10!$row id object] id object
        if {$id >= 256 || $id eq ""} {return ""}
        return [lindex [hvStateString $object $id] 0]
    }
}

# Serial string to trigger switch
# Example: mqtt: devicename [0|off|1|on|2|toggle];
#          mqtt: pub topic payload [retain];
#          mqtt: [sub|unsub] topic {callback};
# "mqtt:" should be config's serPre (serial Prefix string).
# A single space must follow serPre and precede the key string.
# "device name" must match an allowed device name.
# For "pub": if payload ends in "retain", published message's retain flag is set.
# ";" should be config's serPost (serial terminator character(s)),
#     which should not be any character(s) present in name.
proc mqttserial {data} {
    global cfg

    debug "serial: $data" red
    set fmt [format {%1$s (\w+)\s+([^%2$s]+)%2$s} $cfg(serPre) $cfg(serPost)]
    if {![regexp -nocase $fmt $data match name state]} {
        debug "fail"
        return 0
    } elseif {$name eq ""} {
        return -1
    } else {
        sendCmd $name [createCmd $state]
        return [string length $match]
    }
}

# End Trigger section

# Start Config Section

# Get the config info from cfg file
proc loadconfig {} {
    global cfgfile cfgfileroot cfg
    package require Mk4tcl

    set suffix [hvVariable ApplicationSuffix]
    if {$suffix eq ""} {
        set cfgfile $cfgfileroot.cfg
    } else {
        set cfgfile $cfgfileroot-$suffix.cfg
    }
    mk::file open cfg
    if {![catch {hvConfigFile open $cfgfile} f]} {
        mk::file load cfg $f
        close $f
    }
    # General settings
    mk::view layout cfg.main {
        name value
    }
    # Ext Devices
    mk::view layout cfg.devices {
        name topic state status flag macro_on macro_off stopic ltopic varflag loglevel cmnd lwt trigon trigoff cmdtrig allonoff trigstdcus
    }
    #Int Devices
    mk::view layout cfg.x10 {
        id name topic state level type model stopic ltopic object varflag loglevel retain
    }

    if {[catch {hvConfig Geometry} geometry]} {
        set geometry ""
    }

    set cfg(version) 1
    # update config
    mk::loop row cfg.main {
        array set cfg [mk::get $row name value]
    }
    set saveflag 0
    # if version < 2, need to add version to db
    #   and put <> around topics
    if {$cfg(version) < 2} {
    debug "old version $cfg(version)" red
        set cfg(version) 2
        mk::loop row cfg.devices {
            debug "Updating topic: [mk::get $row topic];" red
            mk::set $row topic <[mk::get $row topic]>
            debug "Now: [mk::get $row topic];" green
        }
        set saveflag 1
    }
    # if version < 3, need to add model and set type
    if {$cfg(version) < 3} {
    debug "old version $cfg(version)" red
        set cfg(version) 3
        debug "Adding Model" green
        mk::loop row cfg.x10 {
            mk::set $row model "x10" type 1
        }
        set saveflag 1
    }
    if {$cfg(version) < 4} {
    debug "old version $cfg(version)" red
        set cfg(version) 4
        debug "Adding new topic types" red
        mk::loop row cfg.devices {
            mk::set $row stopic "" ltopic ""
        }
        mk::loop row cfg.x10 {
            mk::set $row stopic "" ltopic ""
        }
        set saveflag 1
    }
    if {$cfg(version) < 5} {
    debug "old version $cfg(version)" red
        set cfg(version) 5
        debug "Adding Object" red
        mk::loop row cfg.x10 {
            if {[mk::get $row type] == 1} {
                mk::set $row object x10
            } else {
                mk::set $row object light
                set id [mk::get $row id]
                if {$id > 255} {
                    mk::set $row id [expr {$id - 256}]
                }
            }
        }
        set saveflag 1
    }
    if {$cfg(version) < 6} {
    debug "old version $cfg(version)" red
        set cfg(version) 6
        debug "Adding Varflag" red
        mk::loop row cfg.devices {
            mk::set $row varflag 1
        }
        set saveflag 1
    }
    if {$cfg(version) < 7} {
    debug "old version $cfg(version)" red
        set cfg(version) 7
        debug "Addjusting listWidths" red
        lappend cfg(listWidths) 0
        set saveflag 1
    }
    if {$cfg(version) < 8} {
    debug "old version $cfg(version)" red
        set cfg(version) 8
        debug "Adding Varflag" red
        mk::loop row cfg.x10 {
            mk::set $row varflag 1
        }
        set saveflag 1
    }
    if {$cfg(version) < 9} {
    debug "old version $cfg(version)" red
        set cfg(version) 9
        debug "Adding loglevel" red
        mk::loop row cfg.x10 {
            mk::set $row loglevel 0
        }
        mk::loop row cfg.devices {
            mk::set $row loglevel 0
        }
        set saveflag 1
    }
    if {$cfg(version) < 10} {
    debug "old version $cfg(version)" red
        set cfg(version) 10
        debug "Adding retain" red
        mk::loop row cfg.x10 {
            mk::set $row retain 0
        }
        set saveflag 1
    }
    if {$cfg(version) < 11} {
        debug "old version $cfg(version)" red
        set cfg(version) 11
        debug "Adding custom processor" red
        mk::loop row cfg.devices {
            mk::set $row cmnd ""
        }
        set saveflag 1
    }
    if {$cfg(version) < 12} {
    debug "old version $cfg(version)" red
        set cfg(version) 12
        debug "Adding LWT" red
        mk::loop row cfg.devices {
            set topic [mk::get $row topic]
            if {[regexp {^<.+>[0-9]*$} $topic] || \
                [regexp -nocase {^.+/LWT$} $topic]} {
                mk::set $row lwt 1
            } else {
                mk::set $row lwt 0
            }
        }
        set saveflag 1
    }
    if {$cfg(version) < 13} {
    debug "old version $cfg(version)" red
        set cfg(version) 13
        debug "Adding Triggers" red
        mk::loop row cfg.devices {
            set cmnd [mk::get $row cmnd]
            if {$cmnd eq ""} {
                mk::set $row cmdtrig 0
            } else {
                mk::set $row cmdtrig 1
            }
            mk::set $row trigstdcus 0
            mk::set $row allonoff 0
            mk::set $row trigon ""
            mk::set $row trigoff ""
        }
        set saveflag 1
    }
    debug "New version $cfg(version)" green

    # set any missing cfg items into cfg.main
    foreach {var val} [array get cfg] {
        if {[mk::select cfg.main name $var] == ""} {
            mk::row append cfg.main name $var value $val
            set saveflag 1
        }
    }
    if {$cfg(clientID) eq ""} {
        binary scan [::uuid::generate] H* uuid
        append cfg(clientID) "HVXL" [string range $uuid end-15 end]
        # save new clientID for later use
        set saveflag 1
    }

    if {$saveflag} {saveconfig}

    # clear state and status for devices
    mk::loop row cfg.devices {
        mk::set $row state "-" status 0
    }
}

# Save config changes to cfg file
proc saveconfig {{top ""}} {
    global cfg cfgfile

    if {[winfo exists .mqtt]} {
        set cfg(geometry) [wm geometry .mqtt]
    }
    mk::view size cfg.main 0
    foreach {var val} [array get cfg] {
        mk::row append cfg.main name $var value $val
    }
    set bkup mqtt-[pid].$$$
    set rc [catch {hvConfigFile create $bkup w} f]
#    debug "save:$rc;" red
    if {$rc == 0} {
        mk::file save cfg $f
        close $f
        hvConfigFile delete $cfgfile
        hvConfigFile rename $bkup $cfgfile
    } elseif {$top ne ""} {
        ttk::messageBox -parent $top -message $f -icon error -type ok
    } else {
        debug "Failed to save configuration: $f"
    }
    return [expr {!$rc}]
}

# MQTT configuration screen
proc cfg_mqtt {} {
    global cfg noid

    if {[winfo exists .mqtt]} {
        wm withdraw .mqtt
        wm deiconify .mqtt
        return
    }
    ttk::toplevel .mqtt
    wm withdraw .mqtt
    wm title .mqtt "MQTT Configuration"
   # wm resizable .mqtt 0 0

    ttk::notebook .mqtt.f

    # Ext Devices tab
    ttk::frame .mqtt.f.f1 -relief groove -borderwidth 2
    ttk::frame .mqtt.f.f1.ni
    ttk::frame .mqtt.f.f1.ni.f
    ttk::treeview .mqtt.f.f1.ni.f.tv -columns {name topic state flag macro} \
      -displaycolumns {name topic flag macro state} -show headings -height 5 \
      -yscrollcommand {.mqtt.f.f1.ni.f.vs set} -selectmode browse
    .mqtt.f.f1.ni.f.tv column name -stretch 1 -width 120 -anchor center
    .mqtt.f.f1.ni.f.tv heading name -text "Device Name" -command [list cfg_sort name]
    .mqtt.f.f1.ni.f.tv column topic -stretch 1 -width 120 -anchor center
    .mqtt.f.f1.ni.f.tv heading topic -text "Topic" -command [list cfg_sort topic]
    .mqtt.f.f1.ni.f.tv column state -stretch 1 -width 70 -anchor center
    .mqtt.f.f1.ni.f.tv heading state -text "State"
    .mqtt.f.f1.ni.f.tv column flag -stretch 1 -width 70 -anchor center
    .mqtt.f.f1.ni.f.tv heading flag -text "Flag/Var"
    .mqtt.f.f1.ni.f.tv column macro -stretch 1 -width 70 -anchor center
    .mqtt.f.f1.ni.f.tv heading macro -text "Macro"
    ttk::scrollbar .mqtt.f.f1.ni.f.vs -command {.mqtt.f.f1.ni.f.tv yview}
    grid .mqtt.f.f1.ni.f.tv .mqtt.f.f1.ni.f.vs -sticky news
    grid columnconfigure .mqtt.f.f1.ni.f .mqtt.f.f1.ni.f.tv -weight 1
    grid rowconfigure .mqtt.f.f1.ni.f .mqtt.f.f1.ni.f.tv -weight 1
    ttk::button .mqtt.f.f1.ni.b1 -text Edit -command cfg_device_chgdlg -state disabled \
        -image [imglist quickedit] -compound left
    ttk::button .mqtt.f.f1.ni.b2 -text New -command {cfg_device_addnew ext} \
        -image [imglist add] -compound left
    ttk::button .mqtt.f.f1.ni.b3 -text Delete -command {cfg_device_del ext} -state disabled \
        -image [imglist delete] -compound left
    grid .mqtt.f.f1.ni.f - - -padx 4 -pady 4 -sticky wens
    grid .mqtt.f.f1.ni.b1 .mqtt.f.f1.ni.b2 .mqtt.f.f1.ni.b3 -padx 4 -pady 4 -sticky ew
    grid columnconfigure .mqtt.f.f1.ni all -weight 1
    grid rowconfigure .mqtt.f.f1.ni .mqtt.f.f1.ni.f -weight 1
    bind .mqtt.f.f1.ni.f.tv <<TreeviewSelect>> {cfg_devicesel %W}
    bind .mqtt.f.f1.ni.f.tv <Double-1> {cfg_device_dbl %W %x %y}
    destroy .rtclkMenu
    set m [menu .rtclkMenu]
    $m add command -label "Off" -command {cfg_rtclkdlg Off}
    $m add command -label "On" -command {cfg_rtclkdlg On}
    $m add command -label "Toggle" -command {cfg_rtclkdlg Toggle}
    $m add command -label "State" -command {cfg_rtclkdlg State}
    $m add command -label "Set To" -command {cfg_rtclkdlg setto}
    bind .mqtt.f.f1.ni.f.tv <Button-3> {cfg_rtclk ext %W %x %y %X %Y}
    catch {.mqtt.f.f1.ni.f.tv tag configure red -foreground red}
    catch {.mqtt.f.f1.ni.f.tv tag configure black -foreground black}

    cfg_sortlist ext

    grid .mqtt.f.f1.ni -column 0 -columnspan 2 -sticky news -padx 3
    grid rowconfigure .mqtt.f.f1 .mqtt.f.f1.ni  -weight 1
    grid columnconfigure .mqtt.f.f1 1 -weight 1
    grid .mqtt.f.f1 -sticky news  -padx 5 -pady 5

    # Save changes to column widths. Use unmapped dummy widget to
    #  capture values before the treeview widget itself is destroyed.
    ttk::label .mqtt.f.f1.ni.f.tv.canary
    bind .mqtt.f.f1.ni.f.tv.canary <Destroy> bindWidths

    if {[llength [lindex $cfg(listWidths) 0]] == 6} {
        foreach col {#0 #1 #2 #3 #4 #5} wid [lindex $cfg(listWidths) 0] {
            .mqtt.f.f1.ni.f.tv column $col -width $wid
        }
    }

    .mqtt.f add .mqtt.f.f1 -text "Ext Devices" -underline 0

    # Int Objects tab
    ttk::frame .mqtt.f.f3 -relief groove -borderwidth 2
    ttk::frame .mqtt.f.f3.ni
    ttk::frame .mqtt.f.f3.ni.f
    ttk::treeview .mqtt.f.f3.ni.f.tv -columns {name topic state id type level} \
      -displaycolumns {id name topic state level} -show headings -height 5 \
      -yscrollcommand {.mqtt.f.f3.ni.f.vs set} -selectmode browse
    .mqtt.f.f3.ni.f.tv column name -stretch 1 -width 120 -anchor center
    .mqtt.f.f3.ni.f.tv heading name -text "Object Name" -command [list cfg_sort name obj]
    .mqtt.f.f3.ni.f.tv column topic -stretch 1 -width 120 -anchor center
    .mqtt.f.f3.ni.f.tv heading topic -text "Topic" -command [list cfg_sort topic obj]
    .mqtt.f.f3.ni.f.tv column state -stretch 1 -width 70 -anchor center
    .mqtt.f.f3.ni.f.tv heading state -text "State"
    .mqtt.f.f3.ni.f.tv column id -stretch 1 -width 70 -anchor center
    .mqtt.f.f3.ni.f.tv heading id -text "ID" -command [list cfg_sort id obj]
    .mqtt.f.f3.ni.f.tv column type -stretch 1 -width 70 -anchor center
    .mqtt.f.f3.ni.f.tv heading type -text "Type"
    .mqtt.f.f3.ni.f.tv column level -stretch 1 -width 70 -anchor center
    .mqtt.f.f3.ni.f.tv heading level -text "Level"
    ttk::scrollbar .mqtt.f.f3.ni.f.vs -command {.mqtt.f.f3.ni.f.tv yview}
    grid .mqtt.f.f3.ni.f.tv .mqtt.f.f3.ni.f.vs -sticky news
    grid columnconfigure .mqtt.f.f3.ni.f .mqtt.f.f3.ni.f.tv -weight 1
    grid rowconfigure .mqtt.f.f3.ni.f .mqtt.f.f3.ni.f.tv -weight 1
    ttk::button .mqtt.f.f3.ni.b1 -text Edit -command cfg_object_chgdlg -state disabled \
        -image [imglist quickedit] -compound left
    ttk::button .mqtt.f.f3.ni.b2 -text New -command {cfg_device_addnew obj} \
        -image [imglist add] -compound left
    ttk::button .mqtt.f.f3.ni.b3 -text Delete -command {cfg_device_del x10} -state disabled \
        -image [imglist delete] -compound left
    grid .mqtt.f.f3.ni.f - - -padx 4 -pady 4 -sticky wens
    grid .mqtt.f.f3.ni.b1 .mqtt.f.f3.ni.b2 .mqtt.f.f3.ni.b3 -padx 4 -pady 4 -sticky ew

    ttk::separator .mqtt.f.f3.ni.sep2
    grid .mqtt.f.f3.ni.sep2 -column 0 -columnspan 3 -sticky ew -padx 3 -pady 3

    ttk::labelframe .mqtt.f.f3.ni.fo -text "Object Type List Enable"
    ttk::checkbutton .mqtt.f.f3.ni.fo.c1 -text "X-10" -variable cfg(x10Enable) -command {cfg_objenable x10}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c2 -text "Custom Lights" -variable cfg(lightEnable) -command {cfg_objenable light}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c3 -text "Flags" -variable cfg(flagEnable) -command {cfg_objenable flag}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c4 -text "Variables" -variable cfg(varEnable) -command {cfg_objenable var}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c5 -text "HVAC" -variable cfg(hvacEnable) -command {cfg_objenable hvac}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c6 -text "DTS" -variable cfg(tempEnable) -command {cfg_objenable temp}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c7 -text "Analog" -variable cfg(analogEnable) -command {cfg_objenable analog}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c8 -text "Inputs" -variable cfg(inputEnable) -command {cfg_objenable input}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c9 -text "Outputs" -variable cfg(outputEnable) -command {cfg_objenable output}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c10 -text "IR" -variable cfg(irEnable) -command {cfg_objenable ir}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c11 -text "Macros" -variable cfg(macroEnable) -command {cfg_objenable macro}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c12 -text "Scheduled Events" -variable cfg(seEnable) -command {cfg_objenable se}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c13 -text "Periodic Events" -variable cfg(peEnable) -command {cfg_objenable pe}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c14 -text "Timers" -variable cfg(timerEnable) -command {cfg_objenable timer}

    grid .mqtt.f.f3.ni.fo.c1 .mqtt.f.f3.ni.fo.c3 .mqtt.f.f3.ni.fo.c4 .mqtt.f.f3.ni.fo.c8 .mqtt.f.f3.ni.fo.c9  -sticky news -padx 3
    grid .mqtt.f.f3.ni.fo.c2 .mqtt.f.f3.ni.fo.c5 .mqtt.f.f3.ni.fo.c6 .mqtt.f.f3.ni.fo.c7 .mqtt.f.f3.ni.fo.c10  -sticky news -padx 3
    grid .mqtt.f.f3.ni.fo.c11 .mqtt.f.f3.ni.fo.c12 .mqtt.f.f3.ni.fo.c13 .mqtt.f.f3.ni.fo.c14  -sticky news -padx 3
    grid .mqtt.f.f3.ni.fo -columnspan 3 -sticky ew -padx 5 -pady 5

    grid columnconfigure .mqtt.f.f3.ni.fo all -weight 1
    grid columnconfigure .mqtt.f.f3.ni all -weight 1
    grid rowconfigure .mqtt.f.f3.ni .mqtt.f.f3.ni.f -weight 1

    bind .mqtt.f.f3.ni.f.tv <<TreeviewSelect>> {cfg_devicesel %W}
    bind .mqtt.f.f3.ni.f.tv <Double-1> {cfg_device_dbl %W %x %y}
    destroy .rtclkMenuint
    set m [menu .rtclkMenuint]
    $m add command -label "Off" -command {cfg_rtclkdlg Off x10}
    $m add command -label "On" -command {cfg_rtclkdlg On x10}
    $m add command -label "Toggle" -command {cfg_rtclkdlg Toggle x10}
    $m add command -label "State" -command {cfg_rtclkdlg State x10}
    $m add command -label "Set To" -command {cfg_rtclkdlg setto x10}
    bind .mqtt.f.f3.ni.f.tv <Button-3> {cfg_rtclk x10 %W %x %y %X %Y}
    catch {.mqtt.f.f3.ni.f.tv tag configure red -foreground red}
    catch {.mqtt.f.f3.ni.f.tv tag configure black -foreground black}

    cfg_sortlist obj

    grid .mqtt.f.f3.ni -column 0 -columnspan 2 -sticky news -padx 3
    grid rowconfigure .mqtt.f.f3 .mqtt.f.f3.ni -weight 1
    grid columnconfigure .mqtt.f.f3 1 -weight 1
    grid .mqtt.f.f3 -sticky news  -padx 5 -pady 5

    if {[llength [lindex $cfg(listWidths) 1]] == 6} {
        foreach col {#0 #1 #2 #3 #4 #5} wid [lindex $cfg(listWidths) 1] {
            .mqtt.f.f3.ni.f.tv column $col -width $wid
        }
    }

    .mqtt.f add .mqtt.f.f3 -text "Int Objects" -underline 0

    # Settings Tab
    ttk::frame .mqtt.f.f2
    ttk::label .mqtt.f.f2.l17 -text "Command Prefix (<):"  -anchor e
    ttk::entry .mqtt.f.f2.e17 -width 10 -justify center -textvariable cfg(cmndPrefix)
    ttk::label .mqtt.f.f2.l18 -text "State Prefix (<):" -anchor e
    ttk::entry .mqtt.f.f2.e18 -width 10 -justify center -textvariable cfg(statPrefix)
    ttk::label .mqtt.f.f2.l19 -text "Tele Prefix (<):" -anchor e
    ttk::entry .mqtt.f.f2.e19 -width 10 -justify center -textvariable cfg(telePrefix)
    ttk::label .mqtt.f.f2.l20 -text "Power Postfix (>):" -anchor e
    ttk::entry .mqtt.f.f2.e20 -width 10 -justify center -textvariable cfg(pwrPostfix)
    ttk::label .mqtt.f.f2.l21 -text "LWT Postfix (>):" -anchor e
    ttk::entry .mqtt.f.f2.e21 -width 10 -justify center -textvariable cfg(LWTPostfix)
    ttk::label .mqtt.f.f2.l24 -text "Count Payload Text:" -anchor e
    ttk::entry .mqtt.f.f2.e24 -width 10 -justify center -textvariable cfg(cycleTxt)
    ttk::label .mqtt.f.f2.l12 -text "MQTT Broker web/IP Address:" -anchor e
    ttk::entry .mqtt.f.f2.e12 -width 25 -justify center -textvariable cfg(broker)

    bind .mqtt.f <<NotebookTabChanged>> {.mqtt.f.f2.e17 selection clear; focus .mqtt.f.f2.e12; .mqtt.f.f2.e12 icursor end}

    ttk::label .mqtt.f.f2.l13 -text "MQTT Broker Port:" -anchor e
    ttk::entry .mqtt.f.f2.e13 -width 6 -justify center -textvariable cfg(brokerPort)
    ttk::label .mqtt.f.f2.l22 -text "Publish QOS:" -anchor e
    ttk::spinbox .mqtt.f.f2.e22 -width 3 -justify center -values {0 1 2} -textvariable cfg(publishQOS)
    ttk::label .mqtt.f.f2.l23 -text "Subscribe QOS:" -anchor e
    ttk::spinbox .mqtt.f.f2.e23 -width 3 -justify center -values {0 1 2} -textvariable cfg(subscribeQOS)

    ttk::label .mqtt.f.f2.l41 -text "Response uses \"OFF/ON\":" -anchor e
    ttk::label .mqtt.f.f2.l42 -text "Response uses \"0-100\":"  -anchor e
    ttk::label .mqtt.f.f2.l43 -text "Appliance Module" -anchor n
    ttk::label .mqtt.f.f2.l44 -text "All Others"       -anchor n
    ttk::radiobutton .mqtt.f.f2.r41 -variable cfg(appResponseType)   -value "1"
    ttk::radiobutton .mqtt.f.f2.r42 -variable cfg(appResponseType)   -value "0"
    ttk::radiobutton .mqtt.f.f2.r43 -variable cfg(otherResponseType) -value "1"
    ttk::radiobutton .mqtt.f.f2.r44 -variable cfg(otherResponseType) -value "0"

    ttk::label .mqtt.f.f2.l45 -text "State Response:" -anchor e
    ttk::frame .mqtt.f.f2.fr
    ttk::checkbutton .mqtt.f.f2.fr.c45a -text "Power" -variable cfg(pwrStatResponse)  -command cfg_statresp
    ttk::checkbutton .mqtt.f.f2.fr.c45b -text "RESULT" -variable cfg(rstStatResponse) -command cfg_statresp
    ttk::checkbutton .mqtt.f.f2.fr.c45c -text "Dimming" -variable cfg(rstDimming) -command cfg_statresp

    ttk::checkbutton .mqtt.f.f2.c14 -text "Use Username/Password" -variable cfg(userpass) -command cfg_userpass
    ttk::label .mqtt.f.f2.l15 -text "Username:" -anchor e
    ttk::entry .mqtt.f.f2.e15 -width 25 -justify center -textvariable cfg(username)
    ttk::label .mqtt.f.f2.l16 -text "Password:" -anchor e
    ttk::entry .mqtt.f.f2.e16 -width 25 -justify center -textvariable cfg(password) -show *

    ttk::separator .mqtt.f.f2.sep2
    
    ttk::checkbutton .mqtt.f.f2.c31 -variable cfg(logging) -text "Create log file" -command cfg_logsel
    ttk::label .mqtt.f.f2.l31 -text "Log Folder:" -anchor e
    ttk::entry .mqtt.f.f2.e31  -textvariable cfg(logpath) -state readonly
    ttk::button .mqtt.f.f2.b31 -width 0 -text "..." -command [list sel_directory .mqtt cfg(logpath)]
    ttk::label .mqtt.f.f2.l33 -text "Log File Extension:" -anchor e
    ttk::entry .mqtt.f.f2.e33 -textvariable cfg(txtext)

    ttk::separator .mqtt.f.f2.sep

    ttk::label .mqtt.f.f2.l9 -text "Netio string:" -anchor e
    ttk::entry .mqtt.f.f2.e9 -width 10 -justify center -textvariable cfg(netioType)
    ttk::label .mqtt.f.f2.l10 -text "Serial string prefix string:" -anchor e
    ttk::entry .mqtt.f.f2.e10 -width 10 -justify center -textvariable cfg(serPre)
    ttk::label .mqtt.f.f2.l11 -text "Serial string terminator character(s):" -anchor e
    ttk::entry .mqtt.f.f2.e11 -width 5 -justify center -textvariable cfg(serPost)

    grid .mqtt.f.f2.l17 .mqtt.f.f2.e17 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l17     -sticky nes -padx 3
    grid .mqtt.f.f2.l18 .mqtt.f.f2.e18 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l18     -sticky nes -padx 3
    grid .mqtt.f.f2.l19 .mqtt.f.f2.e19 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l19     -sticky nes -padx 3
    grid .mqtt.f.f2.l20 .mqtt.f.f2.e20 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l20     -sticky nes -padx 3
    grid .mqtt.f.f2.l21 .mqtt.f.f2.e21 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l21     -sticky nes -padx 3
    grid .mqtt.f.f2.l24 .mqtt.f.f2.e24 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l24     -sticky nes -padx 3

    grid .mqtt.f.f2.l12 .mqtt.f.f2.e12 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l12     -sticky nes -padx 3
    grid .mqtt.f.f2.l13 .mqtt.f.f2.e13 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l13     -sticky nes -padx 3
    grid .mqtt.f.f2.l22 .mqtt.f.f2.e22 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l22     -sticky nes -padx 3
    grid .mqtt.f.f2.l23 .mqtt.f.f2.e23 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l23     -sticky nes -padx 3

    grid x .mqtt.f.f2.c14  -sticky nws -padx 3
    grid .mqtt.f.f2.l15 .mqtt.f.f2.e15 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l15     -sticky nes -padx 3
    grid .mqtt.f.f2.l16 .mqtt.f.f2.e16 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l16     -sticky nes -padx 3

    grid .mqtt.f.f2.fr.c45a .mqtt.f.f2.fr.c45b .mqtt.f.f2.fr.c45c -sticky n
    grid .mqtt.f.f2.l45 .mqtt.f.f2.fr -sticky n
    grid configure .mqtt.f.f2.l45     -sticky nes -padx 3
    grid configure .mqtt.f.f2.fr      -sticky nws -padx 3

    grid x .mqtt.f.f2.l43 .mqtt.f.f2.l44 -sticky n -padx 3
    grid .mqtt.f.f2.l41 .mqtt.f.f2.r41 .mqtt.f.f2.r43 -sticky n
    grid configure .mqtt.f.f2.l41 -sticky nes -padx 3
    grid .mqtt.f.f2.l42 .mqtt.f.f2.r42 .mqtt.f.f2.r44 -sticky n
    grid configure .mqtt.f.f2.l42 -sticky nes -padx 3

    grid .mqtt.f.f2.sep2 -column 0 -columnspan 3 -sticky ew -padx 3 -pady 3

    grid x .mqtt.f.f2.c31 -sticky nws  -padx 3 -pady 1
    grid .mqtt.f.f2.l31 .mqtt.f.f2.e31 .mqtt.f.f2.b31 -sticky we -padx 3
    grid .mqtt.f.f2.l33 .mqtt.f.f2.e33 -sticky we -padx 3

    grid .mqtt.f.f2.sep -column 0 -columnspan 3 -sticky ew -padx 3 -pady 3

    grid .mqtt.f.f2.l9 .mqtt.f.f2.e9   -sticky nws -padx 3
    grid configure .mqtt.f.f2.l9      -sticky nes -padx 3
    grid .mqtt.f.f2.l10 .mqtt.f.f2.e10 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l10     -sticky nes -padx 3
    grid .mqtt.f.f2.l11 .mqtt.f.f2.e11 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l11     -sticky nes -padx 3

    grid rowconfigure .mqtt.f.f2 all -weight 1
    grid columnconfigure .mqtt.f.f2 all -weight 1
    grid .mqtt.f.f2 -sticky news  -padx 5 -pady 5

    cfg_statresp
    cfg_userpass
    cfg_logsel

    .mqtt.f add .mqtt.f.f2 -text "Settings" -underline 0

    # Discovery Tab
    ttk::frame .mqtt.f.f4
    ttk::label .mqtt.f.f4.l1 -text "Object Type:"
    ttk::combobox .mqtt.f.f4.c1 -state readonly -width 10 -values [createList]
    ttk::frame .mqtt.f.f4.ni
    ttk::frame .mqtt.f.f4.ni.f
    ttk::label .mqtt.f.f4.l2 -text "Choose Object(s)"
    ttk::treeview .mqtt.f.f4.ni.f.tv -columns {nid id name} \
      -displaycolumns {id name} -show headings -height 15 \
      -yscrollcommand {.mqtt.f.f4.ni.f.vs set}
    .mqtt.f.f4.ni.f.tv heading id -text "ID"
    .mqtt.f.f4.ni.f.tv column id -stretch 1 -width 70 -anchor center
    .mqtt.f.f4.ni.f.tv column name -stretch 1 -width 200 -anchor center
    .mqtt.f.f4.ni.f.tv heading name -text "Object Name"
    ttk::scrollbar .mqtt.f.f4.ni.f.vs -command {.mqtt.f.f4.ni.f.tv yview}
    grid .mqtt.f.f4.ni.f.tv .mqtt.f.f4.ni.f.vs -sticky news
#    grid columnconfigure .mqtt.f.f4.ni.f .mqtt.f.f4.ni.f.tv -weight 3
    grid rowconfigure .mqtt.f.f4.ni.f .mqtt.f.f4.ni.f.tv -weight 1

    ttk::label .mqtt.f.f4.l3 -text "Discovery Type:"
    ttk::combobox .mqtt.f.f4.c3 -state readonly -width 10 \
      -values {Test Discover UnDiscover}
    ttk::label .mqtt.f.f4.l4 -text "NO ID in Name?"
    ttk::checkbutton .mqtt.f.f4.c4 -variable noid
    ttk::label .mqtt.f.f4.l5 -text "Underscore to space in Name?"
    ttk::checkbutton .mqtt.f.f4.c5 -variable nous
    ttk::label .mqtt.f.f4.l6 -text "Retain Flag for HA published msgs?"
    ttk::checkbutton .mqtt.f.f4.c6 -variable yesretain
    ttk::label .mqtt.f.f4.l7 -text "Exclude from Device?"
    ttk::checkbutton .mqtt.f.f4.c7 -variable nodevice
    bind .mqtt.f.f4.c1 <<ComboboxSelected>> createObjects
    ttk::button .mqtt.f.f4.b1 -text "Run Discovery" -width 20 -command runDiscovery

    grid .mqtt.f.f4.l1 .mqtt.f.f4.c1 -sticky nws -padx 3 -pady 10
    grid configure .mqtt.f.f4.l1     -sticky nes -padx 3
    grid .mqtt.f.f4.ni.f             -sticky wens -padx 4 -pady 4
    grid .mqtt.f.f4.l2 .mqtt.f.f4.ni -sticky news -padx 3
    grid rowconfigure .mqtt.f.f4.ni .mqtt.f.f4.ni.f -weight 1
    grid configure .mqtt.f.f4.l2     -sticky nes -padx 3
    grid .mqtt.f.f4.l3 .mqtt.f.f4.c3 -sticky nws -padx 3 -pady 10
    grid configure .mqtt.f.f4.l3     -sticky nes -padx 3
    grid .mqtt.f.f4.l4 .mqtt.f.f4.c4 -sticky nws -padx 3 -pady 10
    grid configure .mqtt.f.f4.l4     -sticky nes -padx 3
    grid .mqtt.f.f4.l5 .mqtt.f.f4.c5 -sticky nws -padx 3 -pady 10
    grid configure .mqtt.f.f4.l5     -sticky nes -padx 3
    grid .mqtt.f.f4.l6 .mqtt.f.f4.c6 -sticky nws -padx 3 -pady 10
    grid configure .mqtt.f.f4.l6     -sticky nes -padx 3
    grid .mqtt.f.f4.l7 .mqtt.f.f4.c7 -sticky nws -padx 3 -pady 10
    grid configure .mqtt.f.f4.l7     -sticky nes -padx 3
    grid .mqtt.f.f4.b1  -columnspan 2 -padx {4 13} -pady {2 15}
    grid rowconfigure .mqtt.f.f4 .mqtt.f.f4.ni -weight 1
    grid columnconfigure .mqtt.f.f4 1 -weight 1
    grid .mqtt.f.f4 -sticky news  -padx 5 -pady 5

    .mqtt.f.f4.c1 current 0
    createObjects
    
    .mqtt.f.f4.c3 set "Test"
    
    .mqtt.f add .mqtt.f.f4 -text "Discovery" -state hidden

    grid .mqtt.f -sticky snew -padx 5 -pady 5 -columnspan 3

    ttk::button .mqtt.b3 -text Done -width 8 -command cfg_done \
        -image [imglist ok] -compound left
    grid  .mqtt.b3  -columnspan 3 -padx {4 13} -pady {2 8}
    grid columnconfigure .mqtt all -weight 1
    grid rowconfigure .mqtt .mqtt.f -weight 1
    grid rowconfigure .mqtt .mqtt.b3 -weight 0

    if {[lindex $cfg(listWidths) 2]} {
        .mqtt.f select  [lindex $cfg(listWidths) 2]
    }

    wm protocol .mqtt WM_DELETE_WINDOW {.mqtt.b3 invoke}
    
    bind .mqtt <F4> {enableDiscovery}

    if {[regexp {\+-?[0-9]+\+-?[0-9]+} $cfg(geometry)]} {
        wm geometry .mqtt $cfg(geometry)
    }
    wm deiconify .mqtt
}

set enableDiscovery 0
proc enableDiscovery {} {
    global enableDiscovery
debug "run enable:$enableDiscovery" red
    if {$enableDiscovery == 1} {
        set enableDiscovery 0
        .mqtt.f tab .mqtt.f.f4 -state hidden
    } else {
        set enableDiscovery 1
        .mqtt.f tab .mqtt.f.f4 -state normal
    }
}

proc bindWidths {} {
    global cfg

    lset cfg(listWidths) 0 [lmap col {#0 #1 #2 #3 #4 #5} {.mqtt.f.f1.ni.f.tv column $col -width}]
    lset cfg(listWidths) 1 [lmap col {#0 #1 #2 #3 #4 #5} {.mqtt.f.f3.ni.f.tv column $col -width}]
    lset cfg(listWidths) 2 [.mqtt.f index current]
}

# Get images for Configuration dialog
proc imglist {i} {
    global img

    if {![info exists img($i)]} {
        set img($i) [image create photo \
            -file [file join [hvVariable ImagePath] $i.png]]
        set img([format %sdim $i]) [image create photo -format {png -alpha 0.3} \
            -file [file join [hvVariable ImagePath] $i.png]]
    }
    set dim $img([format %sdim $i])
    return [list $img($i) disabled $dim]
}

proc cfg_varflag {type} {
    global varflag vardbl

    if {$type in {obj ext}} {
        if {$varflag == 1} {
            .mqtt.usr.f1.xb2 state disabled
            .mqtt.usr.f1.xl2 state disabled
            set vardbl 0
        } else {
            if {$type eq "ext"} {
                cfg_varflag_select
            } else {
                cfg_object_varflag_select
            }
        }
    } elseif {$type in {dblext dblobj}} {
            set varflag 0
            if {$type eq "dblext"} {
                cfg_varflag_select
            } else {
                cfg_object_varflag_select
            }
    }
}

proc cfg_varflag_select {} {
    global mqttflag varlist vardbl

    if {$mqttflag > 255 && $mqttflag < 512} {
       set mqttid [expr {$mqttflag - 256}]
       grid x .mqtt.usr.f1
       if {$mqttid+1 == [hvObjectCount var]} {
           set varlist "(VA-[expr {$mqttid+1}] Not available.)"
           set vardbl 0
            .mqtt.usr.f1.xb2 state disabled
            .mqtt.usr.f1.xl2 state disabled
       } else {
            set varlist "(VA-$mqttid, VA-[expr {$mqttid+1}])"
            .mqtt.usr.f1.xb2 state !disabled
            .mqtt.usr.f1.xl2 state !disabled
       }
    } else {
       grid remove .mqtt.usr.f1
    }
}

proc cfg_object_varflag_select {} {
    global mqttobj mqttid varlist vardbl

    if {$mqttobj eq "var"} {
       grid x .mqtt.usr.f1
       if {$mqttid+1 == [hvObjectCount var]} {
           set varlist "(VA-[expr {$mqttid+1}] Not available.)"
           set vardbl 0
            .mqtt.usr.f1.xb2 state disabled
            .mqtt.usr.f1.xl2 state disabled
       } else {
            set varlist "(VA-$mqttid, VA-[expr {$mqttid+1}])"
            .mqtt.usr.f1.xb2 state !disabled
            .mqtt.usr.f1.xl2 state !disabled
       }
    } else {
        grid remove .mqtt.usr.f1
        if {$mqttobj eq "ir"} {
            .mqtt.usr.f2.xb5 state disabled
        } else {
            .mqtt.usr.f2.xb5 state !disabled
        }
    }
}

proc cfg_logsel {} {
    global cfg

    if {$cfg(logging)} {
         grid .mqtt.f.f2.l31 .mqtt.f.f2.e31 .mqtt.f.f2.b31 -sticky we -padx 3
         grid .mqtt.f.f2.l33 .mqtt.f.f2.e33 -sticky we -padx 3
    } else {
        grid remove .mqtt.f.f2.l31 .mqtt.f.f2.e31 .mqtt.f.f2.b31
        grid remove .mqtt.f.f2.l33 .mqtt.f.f2.e33
    }
}

proc sel_directory {top name} {
    upvar #0 $name var
    set dir [ttk::chooseDirectory -initialdir $var -mustexist 1 \
      -parent $top -title "Select directory"]
    if {$dir ne ""} {set var $dir}
}

proc cfg_statresp {} {
    global cfg

    if {!$cfg(pwrStatResponse) && !$cfg(rstStatResponse)} {
        set cfg(pwrStatResponse) 1
    }
    if {$cfg(rstStatResponse)} {
        .mqtt.f.f2.fr.c45c state !disabled
    } else {
        .mqtt.f.f2.fr.c45c state disabled
        set cfg(rstDimming) 0
    }
}

proc cfg_userpass {} {
    global cfg

    if {$cfg(userpass)} {
        grid .mqtt.f.f2.l15 .mqtt.f.f2.e15
        grid .mqtt.f.f2.l16 .mqtt.f.f2.e16
    } else {
        grid remove .mqtt.f.f2.l15 .mqtt.f.f2.e15
        grid remove .mqtt.f.f2.l16 .mqtt.f.f2.e16
    }
}

proc cfg_devicesel {w} {
    set p [winfo parent [winfo parent $w]]
    if {[llength [$w selection]]} {
        $p.b1 state !disabled
        $p.b3 state !disabled
    } else {
        $p.b1 state disabled
        $p.b3 state disabled
    }
}

# Double-click enters edit mode
proc cfg_device_dbl {w x y} {
    # Use identify row instead of item for compatibility with 8.5.8 and 8.5.9
   set p [winfo parent [winfo parent $w]]
    if {[$w identify row $x $y] ne ""} {
        $p.b1 invoke
    }
}

# put up device right-click menu
proc cfg_rtclk {type w x y X Y} {
    global objtypes

    set item [$w identify item $x $y]
    if {$item ne ""} {
        $w selection set $item
        if {$type eq "ext"} {
            tk_popup .rtclkMenu $X $Y
        } else {
            set win .mqtt.f.f3.ni.f.tv
            set item [lindex [$win selection] 0]
            lassign [$win item $item -values] name topic state id tp
            dict for {obj info} $objtypes {
                dict with info {
                    if {$tp == $order} {
                        break
                    }
                }
            }
            if {[dict get $objtypes $obj off] eq ""} {
                .rtclkMenuint entryconfigure  0 -state disabled
            } else {
                .rtclkMenuint entryconfigure  0 -state normal
            }
            if {[dict get $objtypes $obj on] eq ""} {
                .rtclkMenuint entryconfigure  1 -state disabled
            } else {
                .rtclkMenuint entryconfigure  1 -state normal
            }
            if {[dict get $objtypes $obj toggle] eq ""} {
                .rtclkMenuint entryconfigure  2 -state disabled
            } else {
                .rtclkMenuint entryconfigure  2 -state normal
            }
            if {[dict get $objtypes $obj state] eq ""} {
                .rtclkMenuint entryconfigure  3 -state disabled
            } else {
                .rtclkMenuint entryconfigure  3 -state normal
            }
            if {[dict get $objtypes $obj setto] eq ""} {
                .rtclkMenuint entryconfigure  4 -state disabled
            } else {
                .rtclkMenuint entryconfigure  4 -state normal
            }
            tk_popup .rtclkMenuint $X $Y
        }
    }
}

# process command selected in right-click menu
proc cfg_rtclkdlg {cmd {type ext}} {
    global objtypes

    if {$type eq "x10"} {
        set win .mqtt.f.f3.ni.f.tv
        set item [lindex [$win selection] 0]
        lassign [$win item $item -values] name topic state id tp
        dict for {obj info} $objtypes {
            dict with info {
                if {$tp == $order} {
                    if {$cmd eq "setto"} {
                        set cmd ""
                        cfg_rtclksettodlg $win $obj
                    } else {
                        set cmd [set [string tolower $cmd]]
                    }
                    break
                }
            }
        }
    } else {
        set win .mqtt.f.f1.ni.f.tv
        set item [lindex [$win selection] 0]
        lassign [$win item $item -values] name
        if {$cmd eq "setto"} {
            set cmd ""
            cfg_rtclksettodlg $win ext
        }
    }
    if {$cmd ne ""} {
        sendCmd $name [createCmd $cmd]
    }
}

proc cfg_rtclksettodlg {win obj} {
    global setto

    ttk::toplevel .mqtt.st
    wm title .mqtt.st "Configure Device"
    wm transient .mqtt.st .mqtt
    wm withdraw .mqtt.st

    ttk::frame .mqtt.st.f1
    ttk::label .mqtt.st.f1.l1 -text "Set to Value:" -anchor w
    ttk::entry .mqtt.st.f1.e1 -width 5 -textvariable setto
    ttk::frame .mqtt.st.f
    ttk::button .mqtt.st.f.b1 -text OK -width 6 -command [list cfg_rtclksetto $win $obj] \
        -image [imglist ok] -compound left
    ttk::button .mqtt.st.f.b2 -text Cancel -width 6 -command {destroy .mqtt.st} \
        -image [imglist cancel] -compound left
    grid .mqtt.st.f1.l1   .mqtt.st.f1.e1   -padx 4  -pady 1 -sticky we
    grid configure    .mqtt.st.f1.l1    -padx 3  -sticky nes
    grid .mqtt.st.f1         -       -padx 4  -pady 3 -sticky we
    grid .mqtt.st.f.b1 .mqtt.st.f.b2 -padx 20 -pady 4
    grid .mqtt.st.f         -       -padx 4  -pady 3 -sticky we
    grid anchor .mqtt.st.f1 center
    grid anchor .mqtt.st.f center
    bind .mqtt.st.f1.e1 <Return> {.mqtt.st.f.b1 invoke}
    bind .mqtt.st <F1> {hvHelp users}
    center .mqtt.st .mqtt
    grab .mqtt.st
    focus .mqtt.st.f1.e1
}

proc cfg_rtclksetto {win obj} {
    global setto

    if {[string is integer -strict $setto] || [string is double -strict $setto] } {
        set item [lindex [$win selection] 0]
        lassign [$win item $item -values] name
        sendCmd $name $setto
    }
    destroy .mqtt.st
}

proc cfg_validate_cmnd {str} {
    global mqtttopic mqttcmnd mqttcmdtrig
    if {$mqttcmdtrig == 1} {
        if {[string length $str] >= 1} {
                if {[regexp {^\w+$} $str]} {
                    return 1
                }
        } elseif {[string length $str] == 0} {
                    return 1
        }
    } else {
        return 1
    }
    return 0
}

proc cfg_validate {str type var} {
    upvar #0 $var other

    if {$type eq "name"} {
        set otype "topic"
    } else {
        set otype "name"
    }
    if {[cfg_validate_$type $str] && [cfg_validate_$otype $other]} {
        .mqtt.usr.f.b1 state !disabled
    } else {
        .mqtt.usr.f.b1 state disabled
    }
    return 1
}

proc cfg_validate_name {str} {
    if {[string length $str] >= 1} {
        if {$str ne {pub sub unsub}} {
            if {[regexp {^\w+$} $str]} {
                return 1
            }
        }
    }
    return 0
}

proc cfg_validate_topic {str} {
    if {[string length $str] >= 1} {
        if {[cfg_validate_slash $str]} {
            if {[cfg_validate_hash $str]} {
                if {[cfg_validate_plus $str]} {
                    return 1
               }
           }
        }
    }
    return 0
}

proc cfg_validate_slash {str} {
    set tstr [string trim $str /]
    set tl [string length $tstr]
    if {[string length $str] != $tl} {return 0}
    for {set i 1} {$i < $tl} {incr i} {
        if {[string index $tstr $i] ne "/"} {continue}
        if {[string index $tstr $i+1] eq "/"} {return 0}
    }
    return 1
}

proc cfg_validate_hash {str} {
    global mqttcmnd
    set idx [string first {#} $str]
    if {$idx == -1} {return 1}
    # hash only allowed when cmnd is set
    if {[string length $mqttcmnd] < 1 || ![regexp {^\w+$} $mqttcmnd]} {return 0}
    set sl [string length $str]
    if {$sl == 1} {return 1}
    if {$sl == $idx+1 && $sl > 2 && [string index $str $idx-1] eq "/"} {return 1}
    debug "hash Fail:$str;$idx;" red
    return 0
}

proc cfg_validate_plus {str} {
    global mqttcmnd
    set idx [regexp -all -inline -indices {\+} $str]
    if {$idx eq ""} {return 1}
    # + only allowed when cmnd is set
    if {[string length $mqttcmnd] < 1 || ![regexp {^\w+$} $mqttcmnd]} {return 0}
    set sl [string length $str]
    set pass 1
    foreach i $idx {
        set j [lindex $i 0]
        if {$j == 0} {
            if {$sl == 1} {
                continue
            } elseif {[string index $str 1] eq "/"} {continue}
            set pass 0
        } elseif {$j == $sl-1} {
            if {[string index $str $j-1] eq "/"} {continue}
            set pass 0
        } else {
            if {[string index $str $j-1] eq "/" && [string index $str $j+1] eq "/"} {continue}
            set pass 0
        }
    }
    return $pass
}

proc cfg_device_add {} {
    global mqttname mqtttopic mqttstate mqttflag mqttmacro_on mqttmacro_off mqttid mqttcmnd mqttlwt varflag vardbl logrx logtx mqtttrigon mqtttrigoff mqttcmdtrig mqttallonoff mqtttrigstdcus

    if {$mqttname eq "" || $mqtttopic eq ""} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Topic and Name must be supplied."
        return
    }
    if {[string tolower $mqttname] in {sub unsub pub}} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name cannot be $mqttname."
        return
    }
    if {[llength [mk::select cfg.x10 -exact name $mqttname]]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Int)."
        return
    }
    if {[llength [mk::select cfg.devices -exact name $mqttname]]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Ext)."
        return
    }

    if {$mqttflag == 512} {
        set flag "-"
    } else {
        if {$mqttflag > 255} {
            set flag VA-[expr {$mqttflag - 256}]
        } else {
            set flag FL-$mqttflag
        }
    }
    set macro [expr {$mqttmacro_on < 256?$mqttmacro_on:"-"}]/[expr {$mqttmacro_off < 256?$mqttmacro_off:"-"}]

    mk::row append cfg.devices name $mqttname topic $mqtttopic \
        state $mqttstate status 0 flag $mqttflag \
        macro_on $mqttmacro_on macro_off $mqttmacro_off \
        cmnd $mqttcmnd lwt $mqttlwt \
        trigon $mqtttrigon trigoff $mqtttrigoff \
        cmdtrig $mqttcmdtrig allonoff $mqttallonoff \
        varflag [expr {$varflag | ($vardbl<<1)}] loglevel [expr {$logrx | ($logtx<<1)}]

    .mqtt.f.f1.ni.f.tv insert {} end -values [list $mqttname $mqtttopic $mqttstate $flag $macro] -tags black
    destroy .mqtt.usr
    cfg_sortlist ext
}

proc cfg_object_add {} {
    global mqttname mqtttopic mqttstate mqttid mqttobj x10types objtypes varflag vardbl logrx logtx retain

    if {$mqttname eq "" || $mqtttopic eq ""} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Topic and Name must be supplied"
        return
    }
    if {[string tolower $mqttname] in {sub unsub pub}} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name cannot be $mqttname."
        return
    }
    if {[llength [mk::select cfg.x10 -exact name $mqttname]]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Int)"
        return
    }
    if {[llength [mk::select cfg.devices -exact name $mqttname]]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Ext)"
        return
    }

    set mqttmodel ""
    set type [dict get $objtypes $mqttobj order]
    if {$mqttobj eq "x10"} {
        set mqttmodel [lindex [dict keys $x10types] [.mqtt.usr.c3 current]]
        set id [string map {" " -} [hvObjectId x10 $mqttid]]
    } elseif {$mqttobj in {input output}} {
        set id [string toupper [string index $mqttobj 0]][hvObjectId $mqttobj $mqttid]
    } else {
        set id "[string toupper [string range $mqttobj 0 1]]-$mqttid"
    }
    if {$mqttobj eq "light"} {
        set mqttmodel "light"
    }

    if {$mqttobj eq "hvac"} {
        lassign [hvObjectState $mqttobj $mqttid] newstate newlevel mqttmodel
    } else {
        lassign [hvStateString $mqttobj $mqttid] newstate newlevel
        if {$mqttobj in {var temp}} {
            set newlevel $newstate
            set newstate "-"
        } elseif {$mqttobj eq "flag"} {
            set newlevel "-"
        } elseif {$mqttobj in {ir macro se pe timer}} {
            set newlevel "-"
            set newstate "-"
        } elseif {$mqttobj in {input output}} {
            set os [hvObjectState $mqttobj $mqttid]
            if {$os ne ""} {
                set newstate [hvObjectLabel $mqttobj $mqttid $os]
            } else {
                set newstate "Unknown"
            }
            set newlevel "-"
        }
    }

    mk::row append cfg.x10 id $mqttid name $mqttname topic $mqtttopic state $newstate level $newlevel type $type model $mqttmodel object $mqttobj varflag [expr {$varflag | ($vardbl<<1)}] loglevel [expr {$logrx | ($logtx<<1)}] retain $retain

    .mqtt.f.f3.ni.f.tv insert {} end -values [list $mqttname $mqtttopic $mqttstate $id $type $newlevel] -tags black
    destroy .mqtt.usr
    cfg_sortlist obj
}

proc cfg_device_addnew {type} {
    global mqttname mqtttopic mqttstate mqttflag mqttmacro_on mqttmacro_off mqttid mqttobj mqttvarflag varflag mqttvardbl vardbl mqttloglevel logrx logtx mqttretain retain mqttcmnd cmnd mqttlwt lwt mqtttrigon trigon mqtttrigoff trigoff mqttcmdtrig cmdtrig mqttallonoff allonoff mqtttrigstdcus trigstdcus

    set mqttname ""
    set mqtttopic ""
    set mqttstate "-"
    set mqttflag "512"
    set mqttid "256"
    set mqttmacro_on "256"
    set mqttmacro_off "256"
    set mqttobj ""
    set mqttcmnd ""
    set cmnd ""
    set mqtttrigon ""
    set trigon ""
    set mqtttrigoff ""
    set trigoff ""
    set mqttcmdtrig 0
    set cmdtrig 0
    set mqttallonoff 0
    set allonoff 0
    set mqtttrigstdcus 0
    set trigstdcus 0
    set mqttlwt 0
    set lwt 0
    set mqttvarflag 0
    set varflag 0
    set mqttvardbl 0
    set vardbl 0
    set mqttloglevel 0
    set logrx 0
    set logtx 0
    set mqttretain 0
    set retain 0

    if {$type eq "obj"} {
        cfg_object_adddlg
    } else {
        cfg_device_adddlg
    }
}

proc cfg_device_adddlg {} {
    global mqttname mqtttopic mqttvarflag varflag mqttvardbl mqttcmnd cmnd mqttlwt lwt vardbl mqttloglevel logrx logtx mqtttrigon trigon mqtttrigoff trigoff mqttcmdtrig cmdtrig mqttallonoff allonoff mqtttrigstdcus trigstdcus

    set row [mk::select cfg.devices name $mqttname]
    if {$row ne ""} {
        lassign [mk::get cfg.devices!$row varflag loglevel cmnd lwt trigon trigoff cmdtrig allonoff trigstdcus] varflag loglevel cmnd lwt trigon trigoff cmdtrig allonoff trigstdcus
        set vardbl [expr {($varflag & 0x02)>>1}]
        set mqttvardbl $vardbl
        set varflag [expr {$varflag & 0x01}]
        set mqttvarflag $varflag
        set mqttloglevel $loglevel
        set logtx [expr {($loglevel & 0x02)>>1}]
        set logrx [expr {$loglevel & 0x01}]
        set mqttcmnd $cmnd
        set mqttlwt $lwt
        set mqtttrigon $trigon
        set mqtttrigoff $trigoff
        set mqttcmdtrig $cmdtrig
        set mqttallonoff $allonoff
        set mqtttrigstdcus $trigstdcus
    }

    ttk::toplevel .mqtt.usr
    wm title .mqtt.usr "Configure Device"
    wm transient .mqtt.usr .mqtt
    wm withdraw .mqtt.usr
    set labelwidth 12
    debug "width: $labelwidth" red
    ttk::label .mqtt.usr.l1 -text "Name:" -anchor e -width $labelwidth
    ttk::entry .mqtt.usr.e1 -width 20 -textvariable mqttname \
      -validate all -validatecommand "cfg_validate %P name mqtttopic"
    ttk::label .mqtt.usr.l2 -text "Topic:" -anchor e -width $labelwidth
    ttk::entry .mqtt.usr.e2 -width 40 -textvariable mqtttopic \
      -validate all -validatecommand "cfg_validate %P topic mqttname"
    ttk::label .mqtt.usr.l4 -text "Flag/Var:" -anchor e -width $labelwidth
    ttk::combobox .mqtt.usr.cb -state readonly -width 28
    bind .mqtt.usr.cb <<ComboboxSelected>> [list cfg_flag_set .mqtt.usr.cb]
    createflaglist .mqtt.usr.cb
    ttk::frame .mqtt.usr.f1
    ttk::checkbutton .mqtt.usr.f1.xb1 -text "Use Variable as flag" -command {cfg_varflag ext} -variable varflag
    ttk::checkbutton .mqtt.usr.f1.xb2 -text "Use two Variables" -command {cfg_varflag dblext} -variable vardbl
    ttk::label .mqtt.usr.f1.xl2 -textvariable varlist -anchor e
    ttk::label .mqtt.usr.l5 -text "On Macro:" -anchor e -width $labelwidth
    ttk::combobox .mqtt.usr.cb5 -state readonly -width 28
    bind .mqtt.usr.cb5 <<ComboboxSelected>> [list cfg_macro_set .mqtt.usr.cb5 mqttmacro_on]
    createmacrolist .mqtt.usr.cb5 mqttmacro_on
    ttk::label .mqtt.usr.l6 -text "Off Macro:" -anchor e -width $labelwidth
    ttk::combobox .mqtt.usr.cb6 -state readonly -width 28
    bind .mqtt.usr.cb6 <<ComboboxSelected>> [list cfg_macro_set .mqtt.usr.cb6 mqttmacro_off]
    createmacrolist .mqtt.usr.cb6 mqttmacro_off
    ttk::label .mqtt.usr.lr1 -text "Cmd/Trig:" -anchor e -width $labelwidth
    ttk::frame .mqtt.usr.fr1
    ttk::radiobutton .mqtt.usr.fr1.r0 -text "None" -value 0 -variable mqttcmdtrig -command cfg_cmdtrig
    ttk::radiobutton .mqtt.usr.fr1.r1 -text "Command" -value 1 -variable mqttcmdtrig -command cfg_cmdtrig
    ttk::radiobutton .mqtt.usr.fr1.r2 -text "Trigger" -value 2 -variable mqttcmdtrig -command cfg_cmdtrig
    ttk::label .mqtt.usr.lr2 -text "Topic Type:" -anchor e -width $labelwidth
    ttk::frame .mqtt.usr.fr2
    ttk::radiobutton .mqtt.usr.fr2.r5 -text "Standard: " -value 0 -variable mqtttrigstdcus -command cfg_cmdtrig
    ttk::radiobutton .mqtt.usr.fr2.r6 -text "Custom" -value 1 -variable mqtttrigstdcus -command cfg_cmdtrig
    ttk::radiobutton .mqtt.usr.fr2.r3 -text "All" -value 0 -variable mqttallonoff -command cfg_cmdtrig
    ttk::radiobutton .mqtt.usr.fr2.r4 -text "On/Off" -value 1 -variable mqttallonoff -command cfg_cmdtrig
    ttk::label .mqtt.usr.l7 -text "Command:" -anchor e -width $labelwidth
    ttk::entry .mqtt.usr.e7 -width 20 -textvariable mqttcmnd \
      -validate all -validatecommand "cfg_validate_cmnd %P"
    ttk::label .mqtt.usr.l7a -text "Trigger:" -anchor e -width $labelwidth
    ttk::entry .mqtt.usr.e7a -width 20 -textvariable mqtttrigon
    ttk::label .mqtt.usr.l8 -text "Off Trigger:" -anchor e -width $labelwidth
    ttk::entry .mqtt.usr.e8 -width 20 -textvariable mqtttrigoff
    ttk::button .mqtt.usr.b3 -text "Copy Topic to Name"  -command cfg_topic_copy \
        -image [imglist copy] -compound left
    ttk::frame .mqtt.usr.f2
    ttk::checkbutton .mqtt.usr.f2.xb5 -text "Subscribe to Last WIll & Testament" -variable mqttlwt
    ttk::checkbutton .mqtt.usr.f2.xb3 -text "Log received messages" -variable logrx
    ttk::checkbutton .mqtt.usr.f2.xb4 -text "Log sent messages" -variable logtx
    ttk::separator .mqtt.usr.sep
    ttk::frame .mqtt.usr.f
    ttk::button .mqtt.usr.f.b1 -text OK -width 6 -command cfg_device_add -state disabled \
        -image [imglist ok] -compound left
    ttk::button .mqtt.usr.f.b2 -text Cancel -width 6 -command {destroy .mqtt.usr;cfg_sortlist ext} \
        -image [imglist cancel] -compound left
    grid .mqtt.usr.f.b1 .mqtt.usr.f.b2 -padx 20 -pady 4
    grid anchor .mqtt.usr.f center
    grid .mqtt.usr.f1.xb1 -padx 4 -pady 1 -sticky w
    grid .mqtt.usr.f1.xb2 .mqtt.usr.f1.xl2 -padx 4 -pady 1 -sticky w
    grid .mqtt.usr.l2   .mqtt.usr.e2  -padx 4 -pady 1 -sticky we
    grid       x        .mqtt.usr.b3  -padx 4 -pady 1
    grid .mqtt.usr.l1   .mqtt.usr.e1  -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.l4   .mqtt.usr.cb  -padx 4 -pady 1 -sticky we
    grid       x        .mqtt.usr.f1  -sticky w
    grid .mqtt.usr.l5   .mqtt.usr.cb5 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.l6   .mqtt.usr.cb6 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.fr1.r0 .mqtt.usr.fr1.r1 .mqtt.usr.fr1.r2 -sticky w
    grid .mqtt.usr.fr2.r6 .mqtt.usr.fr2.r5 .mqtt.usr.fr2.r3 .mqtt.usr.fr2.r4 -sticky w
    grid .mqtt.usr.lr1   .mqtt.usr.fr1
    grid configure .mqtt.usr.fr1 -column 1 -sticky w
    grid .mqtt.usr.lr2   .mqtt.usr.fr2
    grid configure .mqtt.usr.fr2 -column 1 -sticky w
    grid .mqtt.usr.l7   .mqtt.usr.e7 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.l7a   .mqtt.usr.e7a -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.l8   .mqtt.usr.e8 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.f2.xb5 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.f2.xb3 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.f2.xb4 -padx 4 -pady 1 -sticky we
    grid       x      .mqtt.usr.f2 -sticky w
    grid .mqtt.usr.sep - -padx 2 -pady {2 0} -sticky we
    grid .mqtt.usr.f - -padx 4 -pady 3 -sticky we
    grid columnconfigure .mqtt.usr .mqtt.usr.e2 -weight 1
    bind .mqtt.usr.e2 <Return> {.mqtt.usr.f.b1 invoke}
    bind .mqtt.usr <F1> {hvHelp users}
    center .mqtt.usr .mqtt
    grab .mqtt.usr
    focus .mqtt.usr.e2
    if {$row eq ""} {
        .mqtt.usr.e2 insert 0 "<>"
        .mqtt.usr.e2 icursor 1
    }
    cfg_varflag_select
    cfg_varflag ext
    cfg_cmdtrig
}

proc cfg_cmdtrig {} {
    global mqttallonoff mqttcmdtrig mqtttrigstdcus

    if {$mqttcmdtrig == 0} {
        set mqttallonoff 0
        .mqtt.usr.l4 state !disabled
        .mqtt.usr.cb state !disabled
        .mqtt.usr.l5 state !disabled
        .mqtt.usr.cb5 state !disabled
        .mqtt.usr.l6 state !disabled
        .mqtt.usr.cb6 state !disabled
        .mqtt.usr.f1.xb1 state !disabled
        .mqtt.usr.f1.xb2 state !disabled
        .mqtt.usr.f1.xl2 state !disabled
        .mqtt.usr.fr2.r3 state disabled
        .mqtt.usr.fr2.r4 state disabled
        .mqtt.usr.fr2.r5 state disabled
        .mqtt.usr.fr2.r6 state disabled
        grid remove .mqtt.usr.l7 .mqtt.usr.e7
        grid remove .mqtt.usr.l7a .mqtt.usr.e7a
        grid remove .mqtt.usr.l8 .mqtt.usr.e8
        cfg_varflag ext
    } elseif {$mqttcmdtrig == 1} {
        .mqtt.usr.l4 state disabled
        .mqtt.usr.cb state disabled
        .mqtt.usr.l5 state disabled
        .mqtt.usr.cb5 state disabled
        .mqtt.usr.l6 state disabled
        .mqtt.usr.cb6 state disabled
        .mqtt.usr.f1.xb1 state disabled
        .mqtt.usr.f1.xb2 state disabled
        .mqtt.usr.f1.xl2 state disabled
        .mqtt.usr.l7 configure -text "Command:"
        set mqttallonoff 0
        .mqtt.usr.fr2.r3 state disabled
        .mqtt.usr.fr2.r4 state disabled
        .mqtt.usr.fr2.r5 state disabled
        .mqtt.usr.fr2.r6 state disabled
        grid .mqtt.usr.l7 .mqtt.usr.e7 -padx 4 -pady 1 -sticky we
        grid remove .mqtt.usr.l7a .mqtt.usr.e7a
        grid remove .mqtt.usr.l8 .mqtt.usr.e8
    } elseif {$mqttcmdtrig == 2} {
        .mqtt.usr.l4 state disabled
        .mqtt.usr.cb state disabled
        .mqtt.usr.l5 state disabled
        .mqtt.usr.cb5 state disabled
        .mqtt.usr.l6 state disabled
        .mqtt.usr.cb6 state disabled
        .mqtt.usr.f1.xb1 state disabled
        .mqtt.usr.f1.xb2 state disabled
        .mqtt.usr.f1.xl2 state disabled
        grid remove .mqtt.usr.l7 .mqtt.usr.e7
        grid .mqtt.usr.l7a .mqtt.usr.e7a -padx 4 -pady 1 -sticky we
        if {$mqttallonoff == 1 && $mqtttrigstdcus == 0} {
            .mqtt.usr.l7a configure -text "On Trigger:"
            grid .mqtt.usr.l8 .mqtt.usr.e8 -padx 4 -pady 1 -sticky we
        } else {
            .mqtt.usr.l7a configure -text "Trigger:"
            grid remove .mqtt.usr.l8 .mqtt.usr.e8
        }
        if {$mqtttrigstdcus == 0} {
            .mqtt.usr.fr2.r3 state !disabled
            .mqtt.usr.fr2.r4 state !disabled
        } else {
            .mqtt.usr.fr2.r3 state disabled
            .mqtt.usr.fr2.r4 state disabled
        }
        .mqtt.usr.fr2.r5 state !disabled
        .mqtt.usr.fr2.r6 state !disabled
    }
}

proc cfg_object_adddlg {} {
    global mqttname mqtttopic mqttid mqttobj x10types mqttvarflag varflag mqttvardbl vardbl mqttloglevel logrx logtx mqttretain retain

    set row [mk::select cfg.x10 name $mqttname]
    if {$row ne ""} {
        lassign [mk::get cfg.x10!$row varflag loglevel retain] varflag loglevel mqttretain
        set vardbl [expr {($varflag & 0x02)>>1}]
        set mqttvardbl $vardbl
        set varflag [expr {$varflag & 0x01}]
        set mqttvarflag $varflag
        set mqttloglevel $loglevel
        set logtx [expr {($loglevel & 0x02)>>1}]
        set logrx [expr {$loglevel & 0x01}]
        set retain $mqttretain
    }

    ttk::toplevel .mqtt.usr
    wm title .mqtt.usr "Configure Object"
    wm transient .mqtt.usr .mqtt
    wm withdraw .mqtt.usr
    ttk::label .mqtt.usr.l1 -text "Name:" -anchor w
    ttk::entry .mqtt.usr.e1 -width 20 -textvariable mqttname \
      -validate all -validatecommand "cfg_validate %P name mqtttopic"
    ttk::label .mqtt.usr.l3 -text "Model:"
    ttk::combobox .mqtt.usr.c3 -state readonly -width 40 \
      -values [dict values $x10types]
    ttk::label .mqtt.usr.l2 -text "Topic:" -anchor w
    ttk::entry .mqtt.usr.e2 -width 40 -textvariable mqtttopic \
      -validate all -validatecommand "cfg_validate %P topic mqttname"
    ttk::label .mqtt.usr.l4 -text "Object:" -anchor w
    ttk::combobox .mqtt.usr.cb -state readonly -width 28
    bind .mqtt.usr.cb <<ComboboxSelected>> [list cfg_object_set .mqtt.usr.cb mqttid mqttobj]
    createobjlist .mqtt.usr.cb $mqttobj
    ttk::frame .mqtt.usr.f1
    ttk::checkbutton .mqtt.usr.f1.xb1 -text "Use Variable as flag" -command {cfg_varflag obj} -variable varflag
    ttk::checkbutton .mqtt.usr.f1.xb2 -text "Use two Variables" -command {cfg_varflag dblobj} -variable vardbl
    ttk::label .mqtt.usr.f1.xl2 -textvariable varlist -anchor w

    ttk::button .mqtt.usr.b3 -text "Copy Object to Topic, Name"  -command cfg_object_copy \
        -image [imglist copy] -compound left
    ttk::frame .mqtt.usr.f2
    ttk::checkbutton .mqtt.usr.f2.xb3 -text "Log received messages" -variable logrx
    ttk::checkbutton .mqtt.usr.f2.xb4 -text "Log sent messages" -variable logtx
    ttk::checkbutton .mqtt.usr.f2.xb5 -text "Set Retain flag" -variable retain
    ttk::separator .mqtt.usr.sep
    ttk::frame .mqtt.usr.f
    ttk::button .mqtt.usr.f.b1 -text OK -width 6 -command cfg_object_add -state disabled \
        -image [imglist ok] -compound left
    ttk::button .mqtt.usr.f.b2 -text Cancel -width 6 -command {destroy .mqtt.usr;cfg_sortlist obj} \
        -image [imglist cancel] -compound left
    set row [mk::select cfg.x10 name $mqttname]
    if {![catch {mk::get cfg.x10!$row model} model] && $model ne ""} {
        if {[mk::get cfg.x10!$row object] in {x10 light}} {
            .mqtt.usr.c3 set [dict get $x10types [mk::get cfg.x10!$row model]]
        } else {
            .mqtt.usr.c3 current 0
        }
    } else {
	    .mqtt.usr.c3 current 0
    }
    grid .mqtt.usr.f.b1 .mqtt.usr.f.b2 -padx 20 -pady 4
    grid anchor .mqtt.usr.f center
    grid .mqtt.usr.f1.xb1 -padx 4 -pady 1 -sticky w
    grid .mqtt.usr.f1.xb2 .mqtt.usr.f1.xl2 -padx 4 -pady 1 -sticky w
    grid .mqtt.usr.l4 .mqtt.usr.cb -padx 4 -pady 1 -sticky we
    grid       x      .mqtt.usr.f1 -padx 4 -pady 1
    grid .mqtt.usr.l3 .mqtt.usr.c3 -padx 4 -pady 1 -sticky we
    grid       x      .mqtt.usr.b3  -padx 4 -pady 1
    grid .mqtt.usr.l2 .mqtt.usr.e2 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.l1 .mqtt.usr.e1 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.f2.xb5 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.f2.xb3 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.f2.xb4 -padx 4 -pady 1 -sticky we
    grid       x      .mqtt.usr.f2 -sticky w
    grid .mqtt.usr.sep - -padx 2 -pady {2 0} -sticky we
    grid .mqtt.usr.f - -padx 4 -pady 3 -sticky we
    grid columnconfigure .mqtt.usr .mqtt.usr.e2 -weight 1
    bind .mqtt.usr.e2 <Return> {.mqtt.usr.f.b1 invoke}
    bind .mqtt.usr <F1> {hvHelp users}
    center .mqtt.usr .mqtt
    grab .mqtt.usr
    focus .mqtt.usr.l2
    cfg_varflag obj
    cfg_object_varflag_select
}

proc cfg_device_chgdlg {} {
    global mqttname mqtttopic mqttstate mqttflag mqttmacro_on mqttmacro_off mqttvarflag varflag mqttcmnd mqttlwt mqtttrigon mqtttrigoff mqttcmdtrig mqttallonoff mqtttrigstdcus

    set item [lindex [.mqtt.f.f1.ni.f.tv selection] 0]
    lassign [.mqtt.f.f1.ni.f.tv item $item -values] mqttname mqtttopic mqttstate c macro
    set row [mk::select cfg.devices -exact name $mqttname]
    set mqttcmnd [mk::get cfg.devices!$row cmnd]
    set mqttlwt [mk::get cfg.devices!$row lwt]
    set mqtttrigon [mk::get cfg.devices!$row trigon]
    set mqtttrigoff [mk::get cfg.devices!$row trigoff]
    set mqttcmdtrig [mk::get cfg.devices!$row cmdtrig]
    set mqttallonoff [mk::get cfg.devices!$row allonoff]
    set mqtttrigstdcus [mk::get cfg.devices!$row trigstdcus]
    if {$c eq "-"} {
        set mqttflag 512
    } else {
        lassign [split $c {-}] grp num
        if {$grp eq "VA"} {
            set mqttflag [expr {$num + 256}]
        } else {
            set mqttflag $num
        }
    }
     lassign [split $macro /] mqttmacro_on mqttmacro_off
    if {$mqttmacro_on eq "-"} {
        set mqttmacro_on 256
    }
    if {$mqttmacro_off eq "-"} {
        set mqttmacro_off 256
    }
    cfg_device_adddlg
    .mqtt.usr.f.b1 configure -command [list cfg_device_chg $item]
    cfg_validate $mqtttopic topic mqttname
    cfg_validate_cmnd $mqttcmnd
}

proc cfg_object_chgdlg {} {
    global mqttname mqtttopic mqttstate mqttid mqttobj varflag vardbl

    set item [lindex [.mqtt.f.f3.ni.f.tv selection] 0]
    lassign [.mqtt.f.f3.ni.f.tv item $item -values] mqttname mqtttopic mqttstate c type
    if {$c eq "None" || $c eq "-"} {
        set mqttid 256
        set mqttobj ""
    } else {
        lassign [split $c {-}] grp num
        if {$grp eq "LI"} {
            set mqttid $num
            set mqttobj "light"
        } elseif {$grp eq "FL"} {
            set mqttid $num
            set mqttobj "flag"
        } elseif {$grp eq "VA"} {
            set mqttid $num
            set mqttobj "var"
        } elseif {$grp eq "HV"} {
            set mqttid $num
            set mqttobj "hvac"
        } elseif {$grp eq "TE"} {
            set mqttid $num
            set mqttobj "temp"
        } elseif {$grp eq "AN"} {
            set mqttid $num
            set mqttobj "analog"
        } elseif {$grp eq "IR"} {
            set mqttid $num
            set mqttobj "ir"
        } elseif {$grp eq "MA"} {
            set mqttid $num
            set mqttobj "macro"
        } elseif {$grp eq "SE"} {
            set mqttid $num
            set mqttobj "se"
        } elseif {$grp eq "PE"} {
            set mqttid $num
            set mqttobj "pe"
        } elseif {$grp eq "TI"} {
            set mqttid $num
            set mqttobj "timer"
        } elseif {[regexp {^I[A-Q]$} $grp]} {
            set mqttid [getid input [string index $grp 1] $num]
            set mqttobj "input"
        } elseif {[regexp {^O[A-Q]$} $grp]} {
            set mqttid [getid output [string index $grp 1] $num]
            set mqttobj "output"
        } else {
            set mqttid [expr {(([scan $grp %c] - 65)*16) + $num - 1}]
            set mqttobj "x10"
        }
    }
    cfg_object_adddlg
    .mqtt.usr.f.b1 configure -command [list cfg_object_chg $item]
    cfg_validate $mqtttopic topic mqttname
}

proc cfg_device_chg {item} {
    global mqttname mqtttopic mqttstate mqttflag mqttmacro_on mqttmacro_off mqttcmnd cmnd mqttlwt lwt mqttvarflag varflag mqttvardbl vardbl mqttloglevel logrx logtx mqtttrigon trigon mqtttrigoff trigoff mqttcmdtrig cmdtrig mqttallonoff allonoff mqtttrigstdcus trigstdcus

    lassign [.mqtt.f.f1.ni.f.tv item $item -values] name topic state c macro
    set row [mk::select cfg.devices -exact name $name]
    set cmnd [mk::get cfg.devices!$row cmnd]
debug "$name,$mqttname;$cmnd" blue
    if {$c eq "-"} {
        set flag 512
    } else {
        lassign [split $c {-}] grp num
        if {$grp eq "VA"} {
            set flag [expr {$num + 256}]
        } else {
            set flag $num
        }
    }
    lassign [split $macro /] macro_on macro_off
    if {$macro_on eq "-"} {
        set macro_on 256
    }
     if {$macro_off eq "-"} {
        set macro_off 256
    }

    set row [mk::select cfg.devices -exact name $name]
    if {$mqttname eq $name && $mqtttopic eq $topic \
         && $mqttstate eq $state && $mqttflag eq $flag \
         && $mqttmacro_on eq $macro_on && $mqttmacro_off eq $macro_off \
         && $mqttcmnd eq $cmnd && $mqttlwt eq $lwt \
         && $mqttvarflag eq $varflag && $mqttvardbl eq $vardbl \
         && $mqttloglevel eq ($logrx | $logtx<<1) \
         && $mqtttrigon eq $trigon && $mqtttrigoff eq $trigoff \
         && $mqttcmdtrig eq $cmdtrig && $mqttallonoff eq $allonoff \
         && $mqtttrigstdcus eq $trigstdcus
         } {
        debug "Nothing changed"
        destroy .mqtt.usr
        cfg_sortlist ext
        return
    }
    if {[llength [mk::select cfg.devices -exact name $mqttname]] &&  \
         $row != [mk::select cfg.devices -exact name $mqttname]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Ext)"
        return
    }
    if {[llength [mk::select cfg.x10 -exact name $mqtttopic]]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Topic $mqtttopic already exists (Int)"
        return
    }
    if {[string tolower $mqttname] in {sub unsub pub}} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name cannot be $mqttname."
        return
    }

    if {$mqttflag == 512} {
        set flag "-"
    } else {
        if {$mqttflag > 255} {
            set flag VA-[expr {$mqttflag - 256}]
        } else {
            set flag FL-$mqttflag
        }
    }
    set macro [expr {$mqttmacro_on < 256?$mqttmacro_on:"-"}]/[expr {$mqttmacro_off < 256?$mqttmacro_off:"-"}]

    set cmnd [customCmnd $cmnd $cmdtrig $trigstdcus]

    if {[regexp {<} $topic] && [regexp {>[0-9]*} $topic] && ($lwt && ($lwt ne $mqttlwt || $cmnd ne $mqttcmnd || $topic ne $mqtttopic))} {
        # lwt changed to off and/or topic or callback changed, only for standard topics
        sendMqtt unsub tele $topic LWT $cmnd
    }
    if {$cmnd ne $mqttcmnd || $topic ne $mqtttopic} {
        # the topic and/or callback changed, unsub from original.
        if {[regexp {>[0-9]*} $topic]} {
            # unsubscribe to rst only if default postfix
            sendMqtt unsub stat $topic rst $cmnd
        }
        sendMqtt unsub stat $topic pwr $cmnd
    }

    mk::set cfg.devices!$row name $mqttname topic $mqtttopic  status 0 flag $mqttflag  macro_on $mqttmacro_on macro_off $mqttmacro_off varflag [expr {$varflag | ($vardbl<<1)}] loglevel [expr {$logrx | ($logtx<<1)}] cmnd $mqttcmnd lwt $mqttlwt trigon $mqtttrigon trigoff $mqtttrigoff cmdtrig $mqttcmdtrig allonoff $mqttallonoff trigstdcus $mqtttrigstdcus

    .mqtt.f.f1.ni.f.tv item $item -values [list $mqttname $mqtttopic $mqttstate $flag $macro] -tags black
    destroy .mqtt.usr
    cfg_sortlist ext
}

proc cfg_object_chg {item} {
    global mqttname mqtttopic mqttstate mqttid mqttmodel mqttobj x10types objtypes mqttvarflag varflag mqttvardbl vardbl mqttloglevel logrx logtx mqttretain retain

    lassign [.mqtt.f.f3.ni.f.tv item $item -values] name topic state c type level
    if {$c eq "None" || $c eq "-"} {
        set id 256
    } else {
        lassign [split $c {-}] grp num
        set id $num
        set mqttmodel ""
        if {$grp eq "LI"} {
            set mqttmodel "light"
        } elseif {[regexp {^I[A-Q]$} $grp]} {
            set id [getid input [string index $grp 1] $num]
        } elseif {[regexp {^O[A-Q]$} $grp]} {
            set id [getid output [string index $grp 1] $num]
        } elseif {[string match {[A-P]} $grp]} {
            set id [expr {(([scan $grp %c] - 65)*16) + $num - 1}]
            set mqttmodel [lindex [dict keys $x10types] [.mqtt.usr.c3 current]]
        }
    }

    set row [mk::select cfg.x10 -exact name $name]
    if {![catch {mk::get cfg.x10!$row model}]} {
        set model [mk::get cfg.x10!$row model]
    } else {
        set model ""
    }
    if {$mqttname eq $name && $mqtttopic eq $topic && $mqttid eq $id \
        && $mqttmodel eq $model \
        && $mqttvarflag eq $varflag && $mqttvardbl eq $vardbl \
        && $mqttloglevel eq ($logrx | $logtx<<1) \
        && $mqttretain eq $retain} {
        debug "Nothing changed"
        destroy .mqtt.usr
        cfg_sortlist obj
        return
    }
    if {[llength [mk::select cfg.x10 -exact name $mqttname]] &&  \
         $row != [mk::select cfg.x10 -exact name $mqttname]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Int)"
        return
    }
    if {[llength [mk::select cfg.devices -exact name $mqttname]]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Ext)"
        return
    }
    if {[string tolower $mqttname] in {sub unsub pub}} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name cannot be $mqttname."
        return
    }

    if {$mqttobj eq "x10"} {
        set mqttmodel [lindex [dict keys $x10types] [.mqtt.usr.c3 current]]
        set id [string map {" " -} [hvObjectId x10 $mqttid]]
    } else {
        set mqttmodel ""
        set id "[string toupper [string range $mqttobj 0 1]]-$mqttid"
    }
    set type [dict get $objtypes $mqttobj order]
    set object $mqttobj
    if {$mqttobj eq "light"} {
        set mqttmodel "light"
    }

    mk::set cfg.x10!$row id $mqttid name $mqttname topic $mqtttopic type $type model $mqttmodel object $object varflag [expr {$varflag | ($vardbl<<1)}] loglevel [expr {$logrx | ($logtx<<1)}] retain $retain

    .mqtt.f.f3.ni.f.tv item $item -values [list $mqttname $mqtttopic $mqttstate $id $type $level] -tags black
    destroy .mqtt.usr
    cfg_sortlist obj
}

proc cfg_device_del {type} {

    if {$type eq "x10"} {
        set win .mqtt.f.f3.ni.f.tv
    } else {
        set win .mqtt.f.f1.ni.f.tv
        set type "devices"
    }
    set name [$win set [$win selection] name]
    set row [mk::select cfg.$type -exact name $name]
    lassign [mk::get cfg.$type!$row topic cmnd lwt cndtrig trigstdcus] topic cmnd lwt cmdtrig trigstdcus
    if {$type eq "x10"} {
        sendMqtt unsub cmnd $topic pwr subrecv
    } else {
        set cmnd [customCmnd $cmnd $cmdtrig $trigstdcus]
        if {$lwt && [regexp {<} $topic] && [regexp {>[0-9]*} $topic]} {
            sendMqtt unsub tele $topic LWT $cmnd
        }
        if {[regexp {>[0-9]*} $topic]} {
            sendMqtt unsub stat $topic pwr $cmnd
        }
        sendMqtt unsub stat $topic rst $cmnd
    }
    mk::row delete cfg.$type!$row

    $win delete [$win selection]
}

# set sort orders from clicked headers
proc cfg_sort {type {dev ext}} {
    global cfg

    if {$type eq "id"} {
        if {$cfg(sortX10) == 1} {
            set cfg(sortX10) -1
        } else {
            set cfg(sortX10) 1
        }

    } elseif {$type eq "topic"} {
        set cfg(sortName) 0
        set cfg(sortX10) 0
        if {$cfg(sortTopic) == 1} {
            set cfg(sortTopic) -1
        } else {
            set cfg(sortTopic) 1
        }
    } else {
        set cfg(sortTopic) 0
        set cfg(sortX10) 0
        if {$cfg(sortName) == 1} {
            set cfg(sortName) -1
        } else {
            set cfg(sortName) 1
        }
    }
    cfg_sortlist $dev
}

# Sort device list according to sort orders
proc cfg_sortlist {{type {obj ext}}} {
    foreach t $type {
        cfg_sortlistx $t
    }
}

proc cfg_sortlistx {type} {
    global cfg

    if {[winfo exist .mqtt.usr]} {return}
    if {[winfo exist .mqtt]} {
        if {$type eq "obj"} {
            set device "x10"
            set win .mqtt.f.f3.ni.f.tv
            .mqtt.f.f3.ni.b1 state disabled
            .mqtt.f.f3.ni.b3 state disabled
        } else {
            set device "devices"
            set win .mqtt.f.f1.ni.f.tv
            .mqtt.f.f1.ni.b1 state disabled
            .mqtt.f.f1.ni.b3 state disabled
        }
        if {$cfg(sortX10) != 0} {
            # sort via id field - real sort done below
            set rows [mk::select cfg.$device -sort {type id}]
        } else {
            if {$cfg(sortName) == 0 && $cfg(sortTopic) == 0} {
                set rows [mk::select cfg.$device -globnc topic "*"]
            } elseif {$cfg(sortName) == 1} {
                set rows [mk::select cfg.$device -sort name]
            } elseif {$cfg(sortName) == -1} {
                set rows [mk::select cfg.$device -rsort name]
            } elseif {$cfg(sortTopic) == 1} {
                set rows [mk::select cfg.$device -sort topic]
            } elseif {$cfg(sortTopic) == -1} {
                set rows [mk::select cfg.$device -rsort topic]
            }
        }
        $win delete [$win children {}]
        if {![llength $rows]} {
            return
        }
        if {$type in "ext"} {
            foreach row $rows {
                set tag "black"
                if {[mk::get cfg.$device!$row status] == 1} {
                    set tag "red"
                }
                set values [mk::get cfg.$device!$row name topic state]
                set flag [mk::get cfg.$device!$row flag]
                set macro [mk::get cfg.$device!$row macro_on macro_off]
                if {$flag == 512} {
                    lappend values "-"
                } else {
                    if {$flag > 255} {
                        lappend values VA-[expr {$flag - 256}]
                    } else {
                        lappend values FL-$flag
                    }
                }
                foreach i [lsearch -all $macro "256"] {
                    set macro [lreplace $macro $i $i "-"]
                }
                lappend values [join $macro "/"]
                $win insert {} end -values $values -tags $tag
            }
        } elseif {$type in "obj"} {
            foreach row $rows {
                set tag "black"
                if {[mk::get cfg.$device!$row status] == 1} {
                    set tag "red"
                }
                lassign [mk::get cfg.$device!$row id object state] id object state
                set values $id
                lappend values $tag
                lappend values {*}[mk::get cfg.$device!$row name topic]

                if {$object eq "hvac"} {
                    lappend values [lindex {Off Heat Cool Auto} [expr {($state & 0x06)>>1}]]
                } else {
                    lappend values $state
                }
                if {$object eq "x10"} {
                    lappend values [string map {" " -} [hvObjectId x10 $id]]
                } elseif {$object in {input output}} {
                    lappend values [string toupper [string index $object 0]][hvObjectId $object $id]
                } else {
                    lappend values "[string toupper [string range $object 0 1]]-$id"
                }
                lappend values [string map {a 10 b 11 c 12 d 13 e 14 f 15} [mk::get cfg.$device!$row type]]
                lappend values [mk::get cfg.$device!$row level]
                lappend allvalues $values
            }
            foreach l $allvalues {
                lappend types [lindex $l 6]
            }
            if {$cfg(sortX10) == 1} {
                set types [lsort -integer -unique $types]
            } elseif {$cfg(sortX10) == -1} {
                set types [lsort -integer -unique -decreasing $types]
            } else {
                foreach tp $types {dict set tmp $tp 1}
                set types [dict keys $tmp]
            }
            foreach type $types {
                set tempvalues {}
                foreach l $allvalues {
                    if {[lindex $l 6] == $type} {
                        lappend tempvalues $l
                    }
                }
                if {$cfg(sortX10) == 1} {
                    set tempvalues [lsort -integer -index 0 $tempvalues]
                } elseif {$cfg(sortX10) == -1} {
                    set tempvalues [lsort -integer -index 0 -decreasing $tempvalues]
                }
                foreach values $tempvalues {
                    $win insert {} end -values [lrange $values 2 end] -tags [lindex $values 1]
                }
            }
        }
    }
}

proc cfg_topic_copy {} {
    global mqttname mqtttopic

    set mqttname [string map {" " _ ">" "" "<" "" "/" _} $mqtttopic]
    cfg_validate $mqtttopic topic mqttname
}

proc cfg_object_copy {} {
    global mqttname mqtttopic mqttid mqttobj

    if {$mqttid >= 256} {return}

    if {$mqttobj eq "hvac"} {
        set name "Zone_$mqttid"
    } else {
        set name [hvObjectName $mqttobj $mqttid]
    }
    set mqttname [string map {" " _ "/" _} $name]
    set mqtttopic <[string map {" " "" "/" ""} $name]>
    cfg_validate $mqtttopic topic mqttname
}

#! Process a flag when selected for a device
proc cfg_flag_set {w} {
    global mqttflag

    set c [lindex [split [$w get] ":"] 0]
    if {$c eq "None" || $c eq "-"} {
        set mqttflag 512
    } else {
        lassign [split $c {-}] grp num
        if {$grp eq "VA"} {
            set mqttflag [expr {$num + 256}]
        } else {
            set mqttflag $num
        }
    }
    cfg_varflag_select
    createflaglist $w
}

#! Create flag list for drop-down box
proc createflaglist {widget} {
    global  mqttflag

    set fcnt [hvObjectCount flag]
    set vcnt [hvObjectCount var]

    set val "None"
    for {set v 0; set i 1} {$v < $fcnt} {incr v} {
        set name [hvObjectName flag $v]
        lappend val "FL-$v:$name"
        incr i
    }
    for {set v 0; set i 1} {$v < $vcnt} {incr v} {
        set name [hvObjectName var $v]
        lappend val "VA-$v:$name"
        incr i
    }

    $widget configure -values $val
    if {[llength $val] > 1 && $mqttflag ne "" && $mqttflag < 512} {
        if {$mqttflag < 256} {
            $widget current [expr {$mqttflag + 1}]
        } else {
            $widget current [expr {$mqttflag + $fcnt - 255}]
        }
    } else {
        $widget current 0
        set mqttflag 512
    }
}

#! Process x10 when selected for a device
proc cfg_object_set {w vid vobj} {
    upvar #0 $vid id
    upvar #0 $vobj object

    set c [lindex [split [$w get] ":"] 0]
    if {$c eq "None" || $c eq "-"} {
        set id 256
        set object ""
    } else {
        lassign [split $c {-}] grp num
        if {$grp eq "LI"} {
            set id $num
            set object "light"
        } elseif {$grp eq "FL"} {
            set id $num
            set object "flag"
        } elseif {$grp eq "VA"} {
            set id $num
            set object "var"
        } elseif {$grp eq "HV"} {
            set id $num
            set object "hvac"
        } elseif {$grp eq "TE"} {
            set id $num
            set object "temp"
        } elseif {$grp eq "AN"} {
            set id $num
            set object "analog"
        } elseif {$grp eq "IR"} {
            set id $num
            set object "ir"
        } elseif {$grp eq "MA"} {
            set id $num
            set object "macro"
        } elseif {$grp eq "SE"} {
            set id $num
            set object "se"
        } elseif {$grp eq "PE"} {
            set id $num
            set object "pe"
        } elseif {$grp eq "TI"} {
            set id $num
            set object "timer"
        } elseif {[regexp {^I[A-Q]$} $grp]} {
            set id [getid input [string index $grp 1] $num]
            set object "input"
        } elseif {[regexp {^O[A-Q]$} $grp]} {
            set id [getid output [string index $grp 1] $num]
            set object "output"
        } else {
            set id [expr {(([scan $grp %c] - 65)*16) + $num - 1}]
            set object "x10"
        }
    }
    createobjlist $w $object
    cfg_object_varflag_select
}

proc getid {type grp num} {
    set max 8
    if {$type eq "x10"} {set max 16}
    if {$num < 1 || $num > $max} {return -1}
    set cnt [hvObjectCount $type]
    set i 0
    while {$cnt > $i} {
        if {[string tolower [string index [hvObjectId $type $i] 0]] \
         eq [string tolower $grp]} {
            return [expr {$i + $num - 1}]
        }
        incr i $max
    }
    return -1
}

#! Create hv object list for drop-down box
proc createobjlist {widget {object ""}} {
    global  mqttid mqttobj x10types objlist cfg

    set offset 1
    set cnt 0
    unset -nocomplain objlist
    set val "None"
    if {$cfg(x10Enable) || $object eq "x10"} {
        dict set objlist x10 offset $offset
        set cnt [hvObjectCount x10]
        dict set objlist x10 count $cnt
        for {set v 0; set i 1} {$v < $cnt} {incr v} {
            lappend val "[string map {" " -} [hvObjectId x10 $v]]:[hvObjectName x10 $v]"
            incr i
        }
    }
    foreach obj {light flag var ir hvac temp analog macro se pe timer} {
        if {$cfg(${obj}Enable) || $object eq $obj} {
            set offset [expr {$offset + $cnt}]
            dict set objlist $obj offset $offset
            set cnt [hvObjectCount $obj]
            dict set objlist $obj count $cnt
            for {set v 0; set i 1} {$v < $cnt} {incr v} {
                if {$obj eq "hvac"} {
                    lappend val "[string toupper [string range $obj 0 1]]-$i:Zone $i"
                } else {
                    lappend val "[string toupper [string range $obj 0 1]]-$v:[hvObjectName $obj $v]"
                }
                incr i
            }
        }
    }

    foreach obj {input output} {
        if {$cfg(${obj}Enable) || $object eq $obj} {
            set offset [expr {$offset + $cnt}]
            dict set objlist $obj offset $offset
            set cnt [hvObjectCount $obj]
            dict set objlist $obj count $cnt
            for {set v 0; set i 1} {$v < $cnt} {incr v} {
                lappend val "[string toupper [string index $obj 0]][hvObjectId $obj $v]:[hvObjectName $obj $v]"
                incr i
            }
        }
    }
    $widget configure -values $val
    if {[llength $val] > 1 && $mqttid ne "" && $mqttid < 256} {
        if {$mqttobj eq "x10"} {
            set idx [expr {$mqttid + 1}]
            .mqtt.usr.c3 state !disabled
        } elseif {$mqttobj eq "hvac"} {
            set idx [expr {$mqttid - 1 + [dict get $objlist $mqttobj offset]}]
            .mqtt.usr.c3 current 0
            .mqtt.usr.c3 state disabled
        } else {
            set idx [expr {$mqttid + [dict get $objlist $mqttobj offset]}]
            .mqtt.usr.c3 current 0
            .mqtt.usr.c3 state disabled
        }
        if {$mqttobj eq "light"} {
            .mqtt.usr.c3 current [expr {[lsearch -exact $x10types "light"] / 2}]
        }
        if {[catch {$widget current $idx}]} {
            $widget current 0
            set mqttid 256
            set mqttobj ""
        }
    } else {
        $widget current 0
        set mqttid 256
        set mqttobj ""
    }
}

proc cfg_objenable {object} {
# placeholder in case action is needed.
}

#! Process a macro when selected for a device
proc cfg_macro_set {w var} {
    upvar #0 $var macro

    set c [lindex [split [$w get] ":"] 0]
    if {$c eq "None" || $c eq "-"} {
        set macro 256
    } else {
        set macro $c
    }
    createmacrolist $w $var
}
#! Create macro list for drop-down box
proc createmacrolist {widget var} {
    upvar #0 $var macro

    set cnt [hvObjectCount macro]

    set val "None"
    for {set v 0; set i 1} {$v < $cnt} {incr v} {
        set name [hvObjectName macro $v]
        lappend val "$v:$name"
        incr i
    }

    $widget configure -values $val
    if {[llength $val] > 1 && $macro ne "" && $macro < 256} {
        $widget current [expr {$macro + 1}]
    } else {
        $widget current 0
        set macro 256
    }
}

proc cfg_done {} {
    global cfg

    mk::loop row cfg.main {
        array set tmpcfg [mk::get $row name value]
    }

    if {$tmpcfg(broker) ne $cfg(broker) || $tmpcfg(brokerPort) ne $cfg(brokerPort) \
        || $tmpcfg(userpass) ne $cfg(userpass) \
        || $tmpcfg(username) ne $cfg(username) \
        || $tmpcfg(password) ne $cfg(password) }  {connect}
    if {$tmpcfg(serPre) ne $cfg(serPre)} {
        hvTrigger $tmpcfg(serPre) {}
        hvTrigger $cfg(serPre) [list mqttserial]
    }
    saveconfig
    subscribe
    destroy .mqtt
}

if {[hvGuiInit]} {
    # Set combobox foreground to gray when disabled
    ttk::style map TCombobox -foreground \
        [list disabled #8c8c8c]

    hvMenu [hvMainMenu Main.plugins Plugins] add command \
      -label "MQTT" -command cfg_mqtt

    if {[hvHelpFile mqtt.hlp]} {
        hvMenu [hvMainMenu Help.plugins Plugins] add command \
          -label "MQTT" -command [list hvHelp index]
    }

    bind all <Key-KP_Enter> {event generate %W <Key-Return>}
}

proc init {} {
    global cfg

    loadconfig
    connect
    cinit
    hvTrigger $cfg(serPre) [list mqttserial]
}

proc cinit {} {
    global connected

    after cancel cinit
    if {!$connected} {
        after 2000 cinit
        debug "Not Connected to Controller, waiting" red
        return
    }

    debug "Connected to Controller!" red

    subscribe
    devupdate

    #force updates
    foreach object {x10 light flag hvac var analog input output} {
        if {[hvObjectCount $object] > 0} {
            hvEventHook ${object}update [list objupdate $object]
            action $object update
        }
    }
    if {[hvObjectCount temp] > 0} {
        hvEventHook digitaltempupdate [list objupdate temp]
        action temp update
    }
}

proc discinit {} {
    global connected

    debug "Disconnected from Controller!" red
    set connected 0
    subscribe unsub
    cinit
}

# End Configuration section

# Start when HomeVisionXL is ready
hvEventHook connect [list set connected 1]
hvEventHook disconnect discinit
# Reconfigure when a new schedule is opened
hvEventHook ready init
# Gracefully close MQTT session when exiting
hvEventHook exit disconnect
