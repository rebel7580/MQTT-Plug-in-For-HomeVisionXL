# MQTT plugin for HomeVision - Ron Boston
# Parts borrowed from plug-ins written by Schelte Bron
# Version 1.0
# $Revision: 1.61 $
# $Date: 2019/11/01 04:42:10 $

hvImport debug
hvImport action
hvImport -name cnetio netio
hvImport -name cnetioaction netioaction

set version {$Id: hvmqtt.hap,v 1.61 2019/11/01 04:42:10 ron Exp $}
debug "$version" blue

tcl::tm::path add [file dirname [info script]]
set cfgfileroot [file tail [file rootnam [info script]]]

array set cfg {
    serPre "mqtt:"
    serPost ";"
    netioType "mqtt"
    geometry  ""
    sortTopic 0
    sortName 0
    sortX10 0
    broker  "localhost"
    brokerPort 1883
    userpass 0
    username ""
    password ""
    clientID ""
    cmndPrefix "cmnd"
    statPrefix "stat"
    telePrefix "tele"
    pwrPostfix "POWER"
    rstPostfix "RESULT"
    LWTPostfix "LWT"
    publishQOS 1
    subscribeQOS 2
    x10Enable  1
    lightEnable  1
    varEnable  0
    flagEnable 0
    hvacEnable 0
    tempEnable 0
    analogEnable 0
    inputEnable  0
    outputEnable 0
    listWidths  {0 0 0}
    logging      0
    logpath      ""
    appResponseType   1
    otherResponseType 1
}
set cfg(txtext) [expr {$tcl_platform(platform) eq "windows" ? ".txt" : ""}]

set x10types {
    none  ""
	x10	"Standard X-10 Lamp Module"
	app	"Standard X-10 Applicance Module"
	ext	"X-10 Lamp Module with Direct Level Control"
	pcs	"Powerline Control Systems (PCS) Lamp Module"
    light "Custom Lights"
}

set objtypes {
    x10    {order 1 on on   off off   toggle toggle state state set on   clear off   setto on  cycle ""}
    light  {order 2 on on   off off   toggle toggle state state set on   clear off   setto on  cycle ""}
    flag   {order 3 on set  off clear toggle toggle state state set set  clear clear setto ""  cycle ""}
    var    {order 4 on on   off off   toggle toggle state state set set  clear ""    setto set cycle cycle}
    hvac   {order 5 on ""   off ""    toggle ""     state state set ""   clear ""    setto on  cycle ""}
    temp   {order 6 on ""   off ""    toggle ""     state state set ""   clear ""    setto ""  cycle ""}
    analog {order 7 on ""   off ""    toggle ""     state state set ""   clear ""    setto ""  cycle ""}
    input  {order 8 on ""   off ""    toggle ""     state state set ""   clear ""    setto ""  cycle ""     high ""   low low}
    output {order 9 on high off low   toggle toggle state state set high clear low   setto ""  cycle ""     high high low low}
}

set updtfp  {
    x10  0
    light 0
    flag 0
    var 0
    hvac 0
    temp 0
    analog  0
    input   0
    output  0
}

set connected 0
set mymqtt ""

package require mqtt 1.0
package require uuid 1.0.5

# Start MQTT Section

# create local mqtt log command
mqtt log {str} {
    debug $str green
} 

proc connect {} {
    global mymqtt cfg
debug "connect" red
    if {[info exists mymqtt] && $mymqtt ne ""} {
        $mymqtt destroy
    }
    if {$cfg(userpass) && $cfg(username) ne "" && $cfg(password) ne ""} {
        set mymqtt [mqtt new -username $cfg(username) -password $cfg(password)]
    } else {
    set mymqtt [mqtt new]
    }
    $mymqtt connect $cfg(clientID) $cfg(broker) $cfg(brokerPort)
}

proc disconnect {} {
    global mymqtt
    
    debug "BYE!" red
    if {[info exists mymqtt] && $mymqtt ne ""} {
        subscribe unsub
        $mymqtt disconnect
    }
}

# Read MQTT response
proc subrecv {topic msg} {
    global cfg objtypes regMqtt

    set f [string first / $topic]
    set type [string range $topic 0 $f-1]
    set l [string last / $topic]
    set device [string range $topic $f+1 $l-1]
    set resp [string range $topic $l+1 end]
    set fmt [format {(%s|%s|%s)([1-9]?)$} $cfg(rstPostfix) $cfg(pwrPostfix) $cfg(LWTPostfix)]
    if {![regexp $fmt $resp --> resp idx]} {
        set match [format {^%s$} $device]
    } else {
        set match [format {^<*%s>*%s$} $device $idx]
    }
    debug "Recv'd: $type:$device:$resp, $msg" red
    switch $type \
        $cfg(statPrefix) - $cfg(telePrefix) {
            switch $resp \
                $cfg(rstPostfix) - $cfg(pwrPostfix) {
                    if {$resp eq $cfg(rstPostfix)} {
                        set fmt "\{\"POWER\":\"(\\w+)\"\}"
                        if {![regexp $fmt $msg --> payload]} {return}
                        set payload [string tolower $payload]
                    } else {
                        set payload [string tolower $msg]
                        }
                    debug "$resp: payload:$payload;" red
                    set row [mk::select cfg.devices -regexp topic $match]
            if {$row ne ""} {
                        lassign [mk::get cfg.devices!$row flag macro_on macro_off varflag loglevel] id macro_on macro_off varflag loglevel
                        if {$loglevel & 0x01} {
                            mqttlog "rx: $topic $msg"
                        }
                        if {$payload eq {}} {
                    debug "No payload: $topic: $msg" red
                        } elseif {$payload eq "on"} {
                    mk::set cfg.devices!$row state "On" status 0
                            if {$id ne "" && $id < 512} {
                                if {$id < 256} {
                                    action flag set $id
                                } elseif {$varflag & 0x01} {
                                    set id [expr {$id - 256}]
                                    action var set $id 1
                                    action var update
                     }
                    }
                            if {$macro_on ne "" && $macro_on < 256 && $varflag & 0x01} {
                                action macro run $macro_on
                    }
                        } elseif {$payload eq "off"} {
                    mk::set cfg.devices!$row state "Off" status 0
                            if {$id ne "" && $id < 512} {
                                if {$id < 256} {
                                    action flag clear $id
                                } elseif {$varflag & 0x01} {
                                    set id [expr {$id - 256}]
                                    action var set $id 0
                                    action var update
                    }
                    }
                            if {$macro_off ne "" && $macro_off < 256 && $varflag & 0x01} {
                                action macro run $macro_off
                    }
                        } elseif {[string first "cycle" $payload] != -1} {
                            mk::set cfg.devices!$row state "Cyc" status 0
                            if {$id ne "" && $id < 512} {
                            debug "id:$id;v:$varflag" darkred
                                if {$id > 255 && !($varflag & 0x01)} {
                                    set id [expr {$id - 256}]
                                    if {$varflag & 0x02} {
                                        if {[hvStateString var $id] == 255 && ![catch {hvObjectState var [expr {$id+1}]}]} {
                                            action var increment [expr {$id+1}]
                                        }
                                    }
                                    action var increment $id
                                    action var update
                                }
                            }
                            if {$macro_on ne "" && $macro_on < 256 && !($varflag & 0x01)} {
                                action macro run $macro_on
                            }
                        } else {
                            lassign $payload st val
                            if {($st eq "on" && \
                                ([string is integer -strict $val] || [string is double -strict $val])) \
                             || ([string is integer -strict $st] || [string is double -strict $st])} {
                                if {$st ne "on"} {set val $st}
                                set val [expr {0xffff & int($val)}]
                                mk::set cfg.devices!$row state $val status 0
                            if {$id ne "" && $id < 512} {
                                if {$id < 256} {
                                        if {[expr {0x01 & $val}]} {
                                        action flag set $id
                        } else {
                                        action flag clear $id
                                    }
                                } else {
                                    set id [expr {$id - 256}]
                                        if {$varflag & 0x01} {
                                            if {0x01 & $val} {
                                                set val 1
                                            } else {
                                                set val 0
                                            }
                                        } else {
                                            if {$varflag & 0x02 && ![catch {hvObjectState var [expr {$id+1}]}]} {
                                                action var set [expr {$id+1}] [expr {$val / 256}]
                                                set val [expr {$val % 256}]
                                }
                            }
                                        action var set $id [expr {0xff & $val}]
                                    action var update
                        }
                    }
                                if {$macro_on ne "" && $macro_on < 256} {
                                    if {!($varflag & 0x01) || ($varflag & 0x01 && $val & 0x01)} {
                                action macro run $macro_on
                            }
                                }
                                if {$macro_off ne "" && $macro_off < 256} {
                                    if {$varflag & 0x01 && !($val & 0x01)} {
                                        action macro run $macro_off
                                    }
                                }

                        } else {
                            mk::set cfg.devices!$row status 0
                }
                        }
                        cfg_sortlist ext
            }
                } $cfg(LWTPostfix) {
            debug "LWT-$device:$msg" red
                    set row [mk::select cfg.devices -regexp topic $match]
            if {$row ne ""} {
                        lassign [mk::get cfg.devices!$row loglevel] loglevel
                        if {$loglevel & 0x01} {
                            mqttlog "rx: $topic $msg"
                        }
                        set payload [string tolower $msg]
                        if {$payload eq "online"} {
                    mk::set cfg.devices!$row status 0
                        } elseif {$payload eq "offline"} {
                    mk::set cfg.devices!$row status 1
                        }
                        cfg_sortlist ext
                   }
                } default {
                    debug "Unknown response: $type, $resp" red
                }
            
        } $cfg(cmndPrefix) {
            if {[string first "homevision" [string tolower $device]] != -1} {
                mqttlog "rx: $topic $msg"
                hvrecv $device $resp $msg
                return
            }
            switch $resp \
                $cfg(pwrPostfix) {
                    set payload [string tolower $msg]
                    if {[info exists regMqtt] && [dict exists $regMqtt <$device>]} {
                        if {$payload eq {} || $payload eq "?"} {
                            set r [cnetio [dict get $regMqtt <$device>] status $device]
                            set r [lsearch -inline -not $r {}]
                            if {$r ne ""} {
                                sendMqtt pub stat <$device> pwr [string toupper [lsearch -inline -not $r {}]]
                            }
                        } else {
                            cnetioaction [dict get $regMqtt <$device>] $device $payload
                        }
                    }
                    set r [mk::select cfg.x10 -regexp topic $match]
                    foreach row $r {
                        lassign [mk::get cfg.x10!$row id topic state level model object varflag loglevel retain] id dtopic state level model object varflag loglevel retain
                        debug "match:$match,row:$row,id:$id,model:$model,object:$object;topic:$topic,dtopic:$dtopic,varflag:$varflag:loglevel:$loglevel;retain:$retain" red
                        if {$loglevel & 0x01} {
                            mqttlog "rx: $topic $msg"
                        }

                        if {$payload eq {} || $payload eq "?"} {
                             debug "No payload: $topic:$msg;" red
                            set objstat [getStatus $row]
                            debug "id:$id,object:$object;topic:$dtopic;objstat:$objstat" red
                            sendMqtt pub stat $dtopic pwr [dict get $objstat cmd] [expr {($loglevel & 0x02)>>1}] $retain
                        } elseif {$payload in {on off toggle set clear low high}} {
                            if {[dict get $objtypes $object $payload] eq ""} {
                                debug "$object: $type, $resp, $payload not supported." red
                            } elseif {$object eq "var"} {
                                if {$payload in {on set}} {
                                    set val 1
                                } elseif {$payload in {off clear}} {
                                    set val 0
                                } elseif {$payload in {toggle}} {
                                    set val[hvStateString var $id]
                                    if {$val eq ""} {return}
                                    if {0x01 & $val} {
                                        set val 0
                        } else {
                                        set val 1
                                    }
                                }
                                mk::set cfg.x10!$row level $val
                                sendMqtt pub stat $dtopic pwr $val [expr {($loglevel & 0x02)>>1}] $retain
                                if {$varflag & 0x02} {
                                    action var set [expr {$id+1}] 0
                                }
                                action var set $id $val
                                action var update
                            } else {
                                if {$object eq "flag"} {
                                    if {$payload eq "toggle"} {
                                        set cmd [string map -nocase {Set Clear Clear Set} $state]
                                    } else {
                                        set cmd [string totitle [dict get $objtypes $object $payload]]
                                    }
                                    set newstate $cmd
                                    set newlevel "-"
                                } elseif {$object in {output}} {
                                    set os [dict get $objtypes $object $payload]
                                    if {$payload eq "toggle"} {
                                        set cmd [hvObjectLabel $object $id 1]
                                        if {$cmd eq $state} {
                                            set cmd [hvObjectLabel $object $id 0]
                                        } 
                                    } else {
                                        set cmd [hvObjectLabel $object $id [string map -nocase {high 1 low 0} $os]]
                                    }
                                    set newstate $cmd
                                    set newlevel "-"
                                } elseif {$object in {x10 light}} {        
                                    set tmppay $payload
                                    if {$payload eq "toggle"} {
                                        set tmppay [string map -nocase {On off Off on} $state]
                                    }
                                    if {$tmppay eq "off"} {
                                        set newstate "Off"
                                        set newlevel 0
                                    } elseif {$tmppay eq "on"} {
                                        set newlevel 100
                                        set newstate "On"
                                    }
                                    set cmd [setCmd $tmppay 100 $model]
                                }
                                debug "id:$id,object:$object;newstate:$state;newlevel:$newlevel" red
                                if {$cmd eq ""} {return}
                                mk::set cfg.x10!$row state $newstate level $newlevel
                                sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                                action $object {*}[concat [dict get $objtypes $object $payload] $id]
                            }
                        } elseif {[string first "cycle" $payload] != -1} {
                            if {$object eq "var" && !($varflag & 0x01)} {  
                                set val [hvStateString var $id]
                                set msb [hvObjectState var [expr {$id+1}]]
                                if {$val eq "" || $msb eq ""} {return}
                                if {$varflag & 0x02} {
                                    if {$val == 255} {
                                        set cmd [expr {($msb+1)*256}]
                                        mk::set cfg.x10!$row level $cmd
                                        action var increment [expr {$id+1}]
                                    } else {
                                        set cmd [expr {($msb)*256 + ($val+1)%256}]
                                        mk::set cfg.x10!$row level $cmd
                                    }
                                } else {
                                    set cmd [expr {($val+1)%256}]
                                    mk::set cfg.x10!$row level $cmd
                                }
                                sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                                action var increment $id
                                action var update
                            }
                        } else {
                            lassign $payload st val
                            if {($st eq "on" && \
                                ([string is integer -strict $val] || [string is double -strict $val])) \
                             || ([string is integer -strict $st] || [string is double -strict $st])} {
                                if {$st ne "on"} {set val $st}
                                if {$object in {x10 light}} {
                                set val [expr {min(100, $val)}]
                                switch $model {
                                    x10 {
                                        set arg [expr {round(16 * $val / 100)}]
                                        set level "level"
                                            set val [levelpercent $model $arg]
                                    }
                                    pcs {
                                            set arg [expr {round(floor(31 * $val / 100))}]
                                            set val [levelpercent $model $arg]
                                        set level "pcslevel"
                                    }
                                    ext {
                                        set arg [expr {round(63 * $val / 100)}]
                                        set level "directtolevel"
                                            set val [levelpercent $model $arg]
                                    }
                                    app {
                                        set arg ""
                                        set level "on"
                                            set val 100
                                    }
                                    light {
                                        set arg [expr {round([hvLightConfigure maxlevel] * $val / 100)}]
                                            lappend arg 0
                                        set level "level"
                                    }
                                    default {
                                        set arg $val
                                        set level "level"
                        }
                    }
                                    set cmd [setCmd "on" $val $model]
                                        mk::set cfg.x10!$row state "On" level $val
                                    
                                    sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                                action $object {*}[concat $level $id $arg]
                                action $object update
                                } elseif {$object eq "flag"} {
                                    if {[expr {0x01 & $val}]} {
                                        set cmd "Set"
                                    } else {
                                        set cmd "Clear"
                                    }
                                    mk::set cfg.x10!$row model $cmd
                                    sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                                    action flag [string tolower $cmd] $id
                                } elseif {$object eq "var"} {
                                    set val [expr {0xffff & int($val)}]
                                    if {$varflag & 0x01} {
                                        if {0x01 & $val} {
                                            set val 1
                                        } else {
                                            set val 0
                                        }
                                        set cmd $val
                                        mk::set cfg.x10!$row level $val
                                    } else {
                                        if {$varflag & 0x02} {
                                            set cmd $val
                                            mk::set cfg.x10!$row level $cmd
                                            action var set [expr {$id+1}] [expr {$val / 256}]
                                            set val [expr {$val % 256}]
                                        } else {
                                            set cmd [expr {0xff & $val}]
                                            mk::set cfg.x10!$row level $cmd
                                        }
                                    }
                                    sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                                    action var set $id [expr {0xff & $val}]
                                    action var update
                                } elseif {$object eq "hvac"} {
                                    if {$val >= 0 && $val <= 99} {
                                        set cmd [lindex {Hold Run} [expr {$state & 0x01}]]
                                        append cmd " " [lindex {Off Heat Cool Auto} [expr {($state & 0x06)>>1}]]
                                        append cmd " " [lindex {Auto On} [expr {($state & 0x08)>>3}]]
                                        append cmd " " $level " " $val
                                        mk::set cfg.x10!$row model $val
                                        sendMqtt pub stat $dtopic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
                                    action hvac setpoint [expr {$id-1}] $val
                                }
                }
            }
                    }
                    }
                    cfg_sortlist obj
                } default {
                    debug "Unknown command: $type, $resp" red
        }
        } default {
            debug "Unknown prefix: $type" red
        }
}

proc levelpercent {model arg} {   
# Calculate level% based on level input
#  EXT     PCS     X10   STORED LEVEL   DISPLAYED %
#  arg     arg     arg       ta         return
# 
# 62,63    31      16      10000         100
# 60,61    30              11111          96
# 58,59    29      15      01111          93
# 56,57    28              11110          90
# 54,55    27      14      01110          87
#
#  8,9      4       2      10010          15
#  6,7      3              00010          12
#  4,5      2       1      10001           9
#  2,3      1              00001           6
#  0,1      0       0      00000           0

    if {$model eq "x10"} {
        set arg [expr {$arg * 2}]
    } elseif {$model eq "ext"} {
        set arg [expr {$arg / 2}]
    }
    if {$arg == 0} {
        set ta 0  
    } elseif {($arg == 31 && $model eq "pcs") || \
              ($arg == 32 && $model eq "x10")} {
        set ta 16
    } else {
        set ta [expr {($arg + 1)/2}]
        if {!($arg & 1)} {
            set ta [expr {$ta + 16}]
        }
    }
    set bStoredLevel [expr {($ta) & 31}]
    if {$bStoredLevel == 0} {return {0}}
    if {$bStoredLevel == 16} {return {100}}
    set bRegularLevel [expr {$bStoredLevel & 15}]
    set sTempResult [expr {$bRegularLevel * 2}]
    if {$bStoredLevel >= 16} {incr sTempResult}
    if {$model eq "x10"} {
        return [expr {int($sTempResult * 3.125)-3}]
    } else {
        return [expr {int($sTempResult * 3.125)}]
    }
}  

proc hvrecv {topic resp msg} {
    global objtypes

    debug "HV Recv'd: $topic, $resp, $msg" red
    if {([string tolower $resp] ne "power") || $msg ni {"" ?}} {
        return
    }
    set ptopic [split $topic /]
    if {[llength $ptopic] == 1} {
        set objs [dict keys $objtypes]
    } elseif {[llength $ptopic] == 2} {
        set objs [string tolower [lindex $ptopic 1]]
        if {$objs ni [dict keys $objtypes]} {
            return
        }
    }
    set match [join $objs |]
    foreach row [mk::select cfg.x10 -regexp object $match -sort object] {
        set objstat [getStatus $row]
        lassign [mk::get cfg.x10!$row topic loglevel retain] otopic loglevel retain
        sendMqtt pub stat $otopic pwr [dict get $objstat cmd] [expr {($loglevel & 0x02)>>1}] $retain
    }
}

proc getStatus {row} {

    lassign [mk::get cfg.x10!$row id name topic state level model object varflag] id name topic state level model object varflag
    if {$id >= 256} {return}
    set cmd [hvStateString $object $id]    
    lassign $cmd newstate newlevel
    set newsetp $model
        if {$object eq "hvac"} {
        lassign [hvObjectState $object $id] newstate newlevel newsetp
        } elseif {$object eq "var"} {
            if {!($varflag & 0x01) && ($varflag & 0x02) && ![catch {hvObjectState $object [expr {$id+1}]} msb]} {
                set cmd [expr {$msb*256 + $newstate}]
            set newlevel $cmd
            } else {
                set cmd $newstate
            set newlevel $newstate       
            }
        set newstate "-"
    } elseif {$object in {temp analog}} {
        set cmd $newstate
        set newlevel $newstate       
        set newstate "-"
    } elseif {$object eq "flag"} {
        set cmd $newstate
        set newlevel "-"
        } elseif {$object in {input output}} {
            set os [hvObjectState $object $id]
            if {$os ne ""} {
            set newstate [hvObjectLabel $object $id $os]
            } else {
            set newstate "Unknown"
            }
        set cmd $newstate
        set newlevel "-"
    } elseif {$object in {x10 light}} {        
        set cmd [setCmd $newstate $newlevel $model]
    }
    return [dict create cmd $cmd newstate $newstate newlevel $newlevel newsetp $newsetp]
}

#  "app"  {0/2 {"on" 100      "off" 0} 1/3 {"on" "ON"        "off" "OFF"}} 
#  other  {0/1 {"on" "$level" "off" 0} 2/3 {"on" "ON $level" "off" "OFF"}} 
proc setCmd {state level model} {
    global cfg

    if {[string tolower $state] eq "off"} {
        if {$model eq "app"} {
            if {$cfg(appResponseType) == 0} {
                set cmd 0
            } else {
                set cmd "OFF"
            }
        } else {
            if {$cfg(appResponseType) == 0} {
                set cmd 0
            } else {
                    set cmd "OFF"
            }
        }
    } elseif {[string tolower $state] eq "on"} {
                    if {$model eq "app"} {
            if {$cfg(otherResponseType) == 0} {
                set cmd 100
            } else {
                        set cmd "ON"
            }
        } else {
            if {$cfg(otherResponseType) == 0} {
                set cmd $level
                    } else {
                set cmd "ON $level"
            }
                    }
                } else {
                    set cmd "Unknown"
                }
}

proc devupdate {} {

    mk::loop row cfg.devices {
        sendCmd [mk::get $row name] ""
    }
}

proc objupdate {type {publish 1}} {
    global updtfp

    debug "got $type update"
    if {![dict get $updtfp $type]} {
        # if first update, this was forced update;
        #   set flag and don't publish
        dict set updtfp $type 1
        set publish 0
        }
    foreach row [mk::select cfg.x10 -regexp object $type] {
        lassign [mk::get cfg.x10!$row id name topic state level model object varflag loglevel retain] id name topic state level model object varflag loglevel retain
        set objstat [getStatus $row]
        dict with objstat {
           if {$newstate ne $state || $newlevel ne $level || $newsetp ne $model} {
                mk::set cfg.x10!$row state $newstate level $newlevel model $newsetp
                 debug "$object:$id-$topic!:$state->$newstate,$level->$newlevel,$model->$newsetp;cmd:$cmd"
                if {$publish} {
                    sendMqtt pub stat $topic pwr $cmd [expr {($loglevel & 0x02)>>1}] $retain
        }
        }
            }
    }
    cfg_sortlist obj
}

proc subscribe {{type sub}} {
    global mymqtt

    mk::loop row cfg.devices {
        lassign [mk::get $row topic cmnd lwt] topic cmnd lwt
        if {$topic ne ""} {
            if {$cmnd eq ""} {
                    set cmnd "subrecv"
            } else {
                hvImport -name Custom_$cmnd $cmnd
                set cmnd Custom_$cmnd
            }
            if {$lwt && [regexp {^<.+>[1-9]?$} $topic]} {
                # subscribe to lwt only if standard topic and lwt flag set
                sendMqtt $type tele $topic LWT $cmnd
            }
            if {[regexp {^.+>[1-9]?$} $topic]} {
                # subscribe to rst only if default postfix
                sendMqtt $type stat $topic rst $cmnd
            }
            sendMqtt $type stat $topic pwr $cmnd
        }
    }
    mk::loop row cfg.x10 {
        set topic [mk::get $row topic]
        if {$topic ne ""} {
            sendMqtt $type cmnd $topic pwr subrecv
        }
    }
    sendMqtt sub cmnd "<homevision/#" "" subrecv
}

# Send command
proc sendCmd {name cmd} {
    global mymqtt

    set retain 0
    if {$name in {pub}} {
        set cmd [join [lassign $cmd topic]]
        set topic [string trim $topic {\}\{}]
        if {[lindex $cmd end] eq "retain"} {
            set cmd [lrange $cmd 0 end-1]
            set retain 1
        }
        set log 1
    } elseif {$name in {sub unsub}} {
        lassign $cmd topic
        set topic [string trim $topic {\}\{}]
        set cmd "subrecv"
        set log 0
    } else {
    foreach device {"devices" "x10"} {
        set row [mk::select cfg.$device name $name]
        if {$row ne ""} {break}
    }
    if {$row eq ""} {return}
        lassign [mk::get cfg.$device!$row topic loglevel retain] topic loglevel retain
        set name "pub"
        set log [expr {($loglevel & 0x02)>>1}]
    }
    sendMqtt $name cmnd $topic pwr $cmd $log $retain
}

# Create command to send
proc createCmd {cmd} {
    if {[string tolower $cmd] in {1 "on"}} {
        set state "on"
    } elseif {[string tolower $cmd] in {0 "off"}} {
        set state "off"
    } elseif {[string tolower $cmd] in {2 "toggle"}} {
        set state "toggle"
    } elseif {[string tolower $cmd] in {"state"}} {
        set state ""
    } else {
        set state $cmd
    }
    return $state
}

proc sendMqtt {action pre topic post cmd args} {
    global cfg mymqtt

    if {![info exists mymqtt] || $mymqtt eq ""} {return}
    lassign $args log retain
    if {$log eq "" } {set log 0}
    if {$retain eq ""} {set retain 0}
    set npre [expr {[info exists cfg(${pre}Prefix)]?$cfg(${pre}Prefix):$pre}]/
    set npost /[expr {[info exists cfg(${post}Postfix)]?$cfg(${post}Postfix):$post}]
    if {$npost ne "/LWT"} {
        append npost "\\2"
    }
    regsub {^<} $topic $npre topic
    regsub {(>)([1-9]?)$} $topic $npost topic

    switch $action {
        pub {
            if {[catch {$mymqtt publish $topic $cmd $cfg(publishQOS) $retain} rc]} {
                debug "Publish failed: $topic, $cmd: $rc" red
            } else {
                debug "Published $topic, $cmd!"
            }
        }
        sub {
            $mymqtt subscribe $topic $cmd $cfg(subscribeQOS)
            debug "Subscribed to $topic, $cmd!"
        }
        unsub {
            $mymqtt unsubscribe $topic $cmd
            debug "Unsubscribed from $topic, $cmd!"
        }
    }
    if {$log} {
        mqttlog "tx: $topic $cmd"
    }
}

#! Write MQTT status information to log file
hvPublic mqttlog
proc mqttlog {str} {
    global loghandle mqttlogdate cfg

    if {!$cfg(logging)} return
    set time [clock seconds]
    set date [clock format $time -format %y%m%d]
    if {![info exists loghandle] || $date ne $mqttlogdate} {
        if {[info exists loghandle]} {
            catch {close $loghandle}
        }
        if {[catch {file mkdir $cfg(logpath)}]} {
            set cfg(logging) 0
            debug "Failed to access MQTT log directory" red
            return
        }
        set file [file join $cfg(logpath) MQTTLog$date$cfg(txtext)]
        if {[file exists $file]} {
            set mod [file mtime $file]
            if {$time - $mod > 86400} {
                file delete $file
            }
        }
        if {[catch {open $file a} loghandle]} {
            unset loghandle
            set cfg(logging) 0
            debug "Failed to open MQTT log file" red
            return
        }
        set mqttlogdate $date
    }
    debug $str red
    puts -nonewline $loghandle "[clock format $time -format "%d.%m.%Y %H.%M.%S"]\t$str\n"
    catch {flush $loghandle}
}

# End MQTT Section

# Start Trigger section

# mqttcomm is called by other plugins to communicate with MQTT.
# Example: mqttcomm {type} {action} {topic} {payload}
# "type" is the name calling plugin's id.
# "action" is "sub" - subscribe this topic
#             "unsub" - unsubscribe this topic
#             "stat" - report status for topic/payload
# "topic" should be enclosed in "<>" to use MQTT's
#         standard pre- and post-fixes
hvPublic mqttcomm
proc mqttcomm {args} {
    global cfg regMqtt mymqtt

    debug "mqtt: $args" red
    if {![info exists mymqtt] || $mymqtt eq ""} {return ""}
    set state [lassign $args type action topic ]
    if {$type eq "" || $action eq "" || $topic eq ""} {return "0"}
    if {$action eq "sub"} {
        dict set regMqtt $topic $type
        sendMqtt sub cmnd $topic pwr subrecv
    } elseif {$action eq "unsub"} {
        dict unset regMqtt $topic
        sendMqtt unsub cmnd $topic pwr subrecv
    } elseif {$action eq "stat"} {
        if {$state eq ""} {return 0}
        sendMqtt pub stat $topic pwr [join $state]
    } elseif {$action in {cmnd pub}} {
        if {$state eq ""} {return 0}
        sendMqtt pub cmnd $topic pwr [join $state]
    }

    return 1
}

# netioaction is called by NetIO "netioaction" command.
# Example: sends: netioaction mqtt devicename [0|off|1|on|2|toggle] 
#          sends: netioaction mqtt pub topic payload [retain]
#          sends: netioaction mqtt [sub|unsub] topic;
# "mqtt" must match config's netioType.
# "device name" must match an allowed device name.
# For "pub": if payload ends in "retain", published message's retain flag is set.
hvPublic netioaction
proc netioaction {args} {
    global cfg
    
    set state [lassign $args type name]
    if {$type ne $cfg(netioType)} {return ""}
    if {$state eq ""} {return ""}
    sendCmd $name [createCmd $state]
}

# netio is called by NetIO "get" command.
# Example: reads: get mqtt name
# "mqtt" must match config's netioType.
# "name" must match an allowed device name.
# Note: For external devices,
#       returns state of the flag or variable value associated with the device,
#       not the actual current state.
#       For X10/Custom Light, returns On/Off. 
#         Use standard x10 Netio gets for better control.
hvPublic netio
proc netio {args} {
    global cfg
debug "netio:$args" blue
    lassign $args type name
    if {$type ne $cfg(netioType)} {return ""}
    
    foreach device {"devices" "x10"} {
        set row [mk::select cfg.$device name $name]
        if {$row ne ""} {break}
    }
    if {$row eq ""} {return ""}

    if {$device eq "devices"} {
    set flag [mk::get cfg.devices!$row flag]
        if {$flag >= 512 || $flag eq ""} {return ""}
    if {$flag > 255} {
        set flag [expr {$flag - 256}]
        return [hvObjectState var $flag]
    } else {
    return [hvObjectState flag $flag]
    }
    } else {
        lassign [mk::get cfg.x10!$row id object] id object
        if {$id >= 256 || $id eq ""} {return ""}
        return [lindex [hvStateString $object $id] 0]
    }
}

# Serial string to trigger switch
# Example: mqtt: devicename [0|off|1|on|2|toggle];
#          mqtt: pub topic payload [retain];
#          mqtt: [sub|unsub] topic;
# "mqtt:" should be config's serPre (serial Prefix string).
# A single space must follow serPre and precede the key string.
# "device name" must match an allowed device name.
# For "pub": if payload ends in "retain", published message's retain flag is set.
# ";" should be config's serPost (serial terminator character(s)),
#     which should not be any character(s) present in name.
proc mqttserial {data} {
    global cfg
    
    debug "serial: $data" red
    set fmt [format {%s (\w+)\s+(.+)%s} $cfg(serPre) $cfg(serPost)]
    if {![regexp -nocase $fmt $data match name state]} {
        debug "fail"
        return 0
    } elseif {$name eq ""} {
        return -1
    } else {
        sendCmd $name [createCmd $state]
        return [string length $match]
    }
}

# End Trigger section

# Start Config Section

# Get the config info from cfg file
proc loadconfig {} {
    global cfgfile cfgfileroot cfg
    package require Mk4tcl

    set suffix [hvVariable ApplicationSuffix]
    if {$suffix eq ""} {
        set cfgfile $cfgfileroot.cfg
    } else {
        set cfgfile $cfgfileroot-$suffix.cfg
    }
    mk::file open cfg
    if {![catch {hvConfigFile open $cfgfile} f]} {
        mk::file load cfg $f
        close $f
    }
    # General settings
    mk::view layout cfg.main {
        name value
    }
    # Ext Devices
    mk::view layout cfg.devices {
        name topic state status flag macro_on macro_off stopic ltopic varflag loglevel cmnd lwt
    }
    #Int Devices
    mk::view layout cfg.x10 {
        id name topic state level type model stopic ltopic object varflag loglevel retain
    }

    if {[catch {hvConfig Geometry} geometry]} {
        set geometry ""
    }

    set cfg(version) 1
    # update config
    mk::loop row cfg.main {
        array set cfg [mk::get $row name value]
    }
    set saveflag 0
    # if version < 2, need to add version to db
    #   and put <> around topics
    if {$cfg(version) < 2} {
    debug "old version $cfg(version)" red
    set cfg(version) 2
        mk::loop row cfg.devices {
            debug "Updating topic: [mk::get $row topic];" red
            mk::set $row topic <[mk::get $row topic]> 
            debug "Now: [mk::get $row topic];" green
        }
        set saveflag 1
    }
    # if version < 3, need to add model and set type
    if {$cfg(version) < 3} {
    debug "old version $cfg(version)" red
        set cfg(version) 3
        debug "Adding Model" green
        mk::loop row cfg.x10 {
            mk::set $row model "x10" type 1
        }
        set saveflag 1
    }
    if {$cfg(version) < 4} {
    debug "old version $cfg(version)" red
        set cfg(version) 4
        debug "Adding new topic types" red
        mk::loop row cfg.devices {
            mk::set $row stopic "" ltopic ""
        }
        mk::loop row cfg.x10 {
            mk::set $row stopic "" ltopic ""
        }
        set saveflag 1
    }
    if {$cfg(version) < 5} {
    debug "old version $cfg(version)" red
        set cfg(version) 5
        debug "Adding Object" red
        mk::loop row cfg.x10 {
            if {[mk::get $row type] == 1} {
                mk::set $row object x10
            } else {
                mk::set $row object light
                set id [mk::get $row id]
                if {$id > 255} {
                    mk::set $row id [expr {$id - 256}]
                }
            }
        }
        set saveflag 1
    }
    if {$cfg(version) < 6} {
    debug "old version $cfg(version)" red
        set cfg(version) 6
        debug "Adding Varflag" red
        mk::loop row cfg.devices {
            mk::set $row varflag 1
        }
        set saveflag 1
    }
    if {$cfg(version) < 7} {
    debug "old version $cfg(version)" red
        set cfg(version) 7
        debug "Addjusting listWidths" red
        lappend cfg(listWidths) 0
        set saveflag 1
    }
    if {$cfg(version) < 8} {
    debug "old version $cfg(version)" red
        set cfg(version) 8
        debug "Adding Varflag" red
        mk::loop row cfg.x10 {
            mk::set $row varflag 1
        }
        set saveflag 1
    }
    if {$cfg(version) < 9} {
    debug "old version $cfg(version)" red
        set cfg(version) 9
        debug "Adding loglevel" red
        mk::loop row cfg.x10 {
            mk::set $row loglevel 0
        }
        mk::loop row cfg.devices {
            mk::set $row loglevel 0
        }        
        set saveflag 1
    }
    if {$cfg(version) < 10} {
    debug "old version $cfg(version)" red
        set cfg(version) 10
        debug "Adding retain" red
        mk::loop row cfg.x10 {
            mk::set $row retain 0
        }       
        set saveflag 1
    }
    if {$cfg(version) < 11} {
        debug "old version $cfg(version)" red
        set cfg(version) 11
        debug "Adding custom processor" red
        mk::loop row cfg.devices {
            mk::set $row cmnd ""
        }
        set saveflag 1
    }
    if {$cfg(version) < 12} {
    debug "old version $cfg(version)" red
        set cfg(version) 12
        debug "Adding LWT" red
        mk::loop row cfg.devices {
            set topic [mk::get $row topic]
            if {[regexp {^<.+>[1-9]?$} $topic] || \
                [regexp -nocase {^.+/LWT$} $topic]} {
                mk::set $row lwt 1
            } else {
                mk::set $row lwt 0
            }
        }
        set saveflag 1
    }
    debug "New version $cfg(version)" green

    # set any missing cfg items into cfg.main
    foreach {var val} [array get cfg] {
        if {[mk::select cfg.main name $var] == ""} {
        mk::row append cfg.main name $var value $val
            set saveflag 1
        }
    }
    if {$cfg(clientID) eq ""} {
        binary scan [::uuid::generate] H* uuid
        append cfg(clientID) "HVXL" [string range $uuid end-15 end]
        # save new clientID for later use
        set saveflag 1
    }

    if {$saveflag} {saveconfig}
    
    # clear state and status for devices
    mk::loop row cfg.devices {
        mk::set $row state "-" status 0
    }
}

# Save config changes to cfg file
proc saveconfig {{top ""}} {
    global cfg cfgfile
    
    if {[winfo exists .mqtt]} {
        set cfg(geometry) [wm geometry .mqtt]
    }
    mk::view size cfg.main 0
    foreach {var val} [array get cfg] {
        mk::row append cfg.main name $var value $val
    }
    set bkup mqtt-[pid].$$$
    set rc [catch {hvConfigFile create $bkup w} f]
    if {$rc == 0} {
        mk::file save cfg $f
        close $f
        hvConfigFile delete $cfgfile
        hvConfigFile rename $bkup $cfgfile
    } elseif {$top ne ""} {
        ttk::messageBox -parent $top -message $f -icon error -type ok
    } else {
        debug "Failed to save configuration: $f"
    }
    return [expr {!$rc}]
}

# MQTT configuration screen
proc cfg_mqtt {} {
    global cfg
    
    if {[winfo exists .mqtt]} {
        wm withdraw .mqtt
        wm deiconify .mqtt
        return
    }
    ttk::toplevel .mqtt
    wm withdraw .mqtt
    wm title .mqtt "MQTT Configuration"
   # wm resizable .mqtt 0 0

    ttk::notebook .mqtt.f
    
    # Ext Devices tab
    ttk::frame .mqtt.f.f1 -relief groove -borderwidth 2
    ttk::frame .mqtt.f.f1.ni
    ttk::frame .mqtt.f.f1.ni.f
    ttk::treeview .mqtt.f.f1.ni.f.tv -columns {name topic state flag macro} \
      -displaycolumns {name topic flag macro state} -show headings -height 5 \
      -yscrollcommand {.mqtt.f.f1.ni.f.vs set} -selectmode browse
    .mqtt.f.f1.ni.f.tv column name -stretch 1 -width 120 -anchor center
    .mqtt.f.f1.ni.f.tv heading name -text "Device Name" -command [list cfg_sort name]
    .mqtt.f.f1.ni.f.tv column topic -stretch 1 -width 120 -anchor center
    .mqtt.f.f1.ni.f.tv heading topic -text "Topic" -command [list cfg_sort topic]
    .mqtt.f.f1.ni.f.tv column state -stretch 1 -width 70 -anchor center
    .mqtt.f.f1.ni.f.tv heading state -text "State"
    .mqtt.f.f1.ni.f.tv column flag -stretch 1 -width 70 -anchor center
    .mqtt.f.f1.ni.f.tv heading flag -text "Flag/Var"
    .mqtt.f.f1.ni.f.tv column macro -stretch 1 -width 70 -anchor center
    .mqtt.f.f1.ni.f.tv heading macro -text "Macro"
    ttk::scrollbar .mqtt.f.f1.ni.f.vs -command {.mqtt.f.f1.ni.f.tv yview}
    grid .mqtt.f.f1.ni.f.tv .mqtt.f.f1.ni.f.vs -sticky news
    grid columnconfigure .mqtt.f.f1.ni.f .mqtt.f.f1.ni.f.tv -weight 1
    grid rowconfigure .mqtt.f.f1.ni.f .mqtt.f.f1.ni.f.tv -weight 1
    ttk::button .mqtt.f.f1.ni.b1 -text Edit -command cfg_device_chgdlg -state disabled \
        -image [imglist quickedit] -compound left
    ttk::button .mqtt.f.f1.ni.b2 -text New -command {cfg_device_addnew ext} \
        -image [imglist add] -compound left   
    ttk::button .mqtt.f.f1.ni.b3 -text Delete -command {cfg_device_del ext} -state disabled \
        -image [imglist delete] -compound left
    grid .mqtt.f.f1.ni.f - - -padx 4 -pady 4 -sticky wens
    grid .mqtt.f.f1.ni.b1 .mqtt.f.f1.ni.b2 .mqtt.f.f1.ni.b3 -padx 4 -pady 4 -sticky ew
    grid columnconfigure .mqtt.f.f1.ni all -weight 1
    grid rowconfigure .mqtt.f.f1.ni .mqtt.f.f1.ni.f -weight 1
    bind .mqtt.f.f1.ni.f.tv <<TreeviewSelect>> {cfg_devicesel %W}
    bind .mqtt.f.f1.ni.f.tv <Double-1> {cfg_device_dbl %W %x %y}
    destroy .rtclkMenu
    set m [menu .rtclkMenu]
    $m add command -label "Off" -command {cfg_rtclkdlg Off}
    $m add command -label "On" -command {cfg_rtclkdlg On}
    $m add command -label "Toggle" -command {cfg_rtclkdlg Toggle}
    $m add command -label "State" -command {cfg_rtclkdlg State}
    bind .mqtt.f.f1.ni.f.tv <Button-3> {cfg_rtclk ext %W %x %y %X %Y}
    catch {.mqtt.f.f1.ni.f.tv tag configure red -foreground red}
    catch {.mqtt.f.f1.ni.f.tv tag configure black -foreground black}

    cfg_sortlist ext
    
    grid .mqtt.f.f1.ni -column 0 -columnspan 2 -sticky news -padx 3
    grid rowconfigure .mqtt.f.f1 .mqtt.f.f1.ni  -weight 1
    grid columnconfigure .mqtt.f.f1 1 -weight 1
    grid .mqtt.f.f1 -sticky news  -padx 5 -pady 5

    # Save changes to column widths. Use unmapped dummy widget to
    #  capture values before the treeview widget itself is destroyed.
    ttk::label .mqtt.f.f1.ni.f.tv.canary
    bind .mqtt.f.f1.ni.f.tv.canary <Destroy> bindWidths

    if {[llength [lindex $cfg(listWidths) 0]] == 6} {
        foreach col {#0 #1 #2 #3 #4 #5} wid [lindex $cfg(listWidths) 0] {
            .mqtt.f.f1.ni.f.tv column $col -width $wid
        }
    }

    .mqtt.f add .mqtt.f.f1 -text "Ext Devices" -underline 0

    # Int Objects tab
    ttk::frame .mqtt.f.f3 -relief groove -borderwidth 2
    ttk::frame .mqtt.f.f3.ni
    ttk::frame .mqtt.f.f3.ni.f
    ttk::treeview .mqtt.f.f3.ni.f.tv -columns {name topic state id type level} \
      -displaycolumns {id name topic state level} -show headings -height 5 \
      -yscrollcommand {.mqtt.f.f3.ni.f.vs set} -selectmode browse
    .mqtt.f.f3.ni.f.tv column name -stretch 1 -width 120 -anchor center
    .mqtt.f.f3.ni.f.tv heading name -text "Object Name" -command [list cfg_sort name obj]
    .mqtt.f.f3.ni.f.tv column topic -stretch 1 -width 120 -anchor center
    .mqtt.f.f3.ni.f.tv heading topic -text "Topic" -command [list cfg_sort topic obj]
    .mqtt.f.f3.ni.f.tv column state -stretch 1 -width 70 -anchor center
    .mqtt.f.f3.ni.f.tv heading state -text "State"
    .mqtt.f.f3.ni.f.tv column id -stretch 1 -width 70 -anchor center
    .mqtt.f.f3.ni.f.tv heading id -text "ID" -command [list cfg_sort id obj]
    .mqtt.f.f3.ni.f.tv column type -stretch 1 -width 70 -anchor center
    .mqtt.f.f3.ni.f.tv heading type -text "Type"
    .mqtt.f.f3.ni.f.tv column level -stretch 1 -width 70 -anchor center
    .mqtt.f.f3.ni.f.tv heading level -text "Level"
    ttk::scrollbar .mqtt.f.f3.ni.f.vs -command {.mqtt.f.f3.ni.f.tv yview}
    grid .mqtt.f.f3.ni.f.tv .mqtt.f.f3.ni.f.vs -sticky news
    grid columnconfigure .mqtt.f.f3.ni.f .mqtt.f.f3.ni.f.tv -weight 1
    grid rowconfigure .mqtt.f.f3.ni.f .mqtt.f.f3.ni.f.tv -weight 1
    ttk::button .mqtt.f.f3.ni.b1 -text Edit -command cfg_object_chgdlg -state disabled \
        -image [imglist quickedit] -compound left
    ttk::button .mqtt.f.f3.ni.b2 -text New -command {cfg_device_addnew obj} \
        -image [imglist add] -compound left   
    ttk::button .mqtt.f.f3.ni.b3 -text Delete -command {cfg_device_del x10} -state disabled \
        -image [imglist delete] -compound left
    grid .mqtt.f.f3.ni.f - - -padx 4 -pady 4 -sticky wens
    grid .mqtt.f.f3.ni.b1 .mqtt.f.f3.ni.b2 .mqtt.f.f3.ni.b3 -padx 4 -pady 4 -sticky ew
    
    ttk::separator .mqtt.f.f3.ni.sep2
    grid .mqtt.f.f3.ni.sep2 -column 0 -columnspan 3 -sticky ew -padx 3 -pady 3
    
    ttk::labelframe .mqtt.f.f3.ni.fo -text "Object Type List Enable"
    ttk::checkbutton .mqtt.f.f3.ni.fo.c1 -text "X-10" -variable cfg(x10Enable) -command {cfg_objenable x10}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c2 -text "Custom Lights" -variable cfg(lightEnable) -command {cfg_objenable light}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c3 -text "Flags" -variable cfg(flagEnable) -command {cfg_objenable flag}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c4 -text "Variables" -variable cfg(varEnable) -command {cfg_objenable var}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c5 -text "HVAC" -variable cfg(hvacEnable) -command {cfg_objenable hvac}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c6 -text "DTS" -variable cfg(tempEnable) -command {cfg_objenable temp}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c7 -text "Analog" -variable cfg(analogEnable) -command {cfg_objenable analog}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c8 -text "Inputs" -variable cfg(inputEnable) -command {cfg_objenable input}
    ttk::checkbutton .mqtt.f.f3.ni.fo.c9 -text "Outputs" -variable cfg(outputEnable) -command {cfg_objenable output}

    grid .mqtt.f.f3.ni.fo.c1 .mqtt.f.f3.ni.fo.c3 .mqtt.f.f3.ni.fo.c4 .mqtt.f.f3.ni.fo.c8 .mqtt.f.f3.ni.fo.c9  -sticky news -padx 3
    grid .mqtt.f.f3.ni.fo.c2 .mqtt.f.f3.ni.fo.c5 .mqtt.f.f3.ni.fo.c6 .mqtt.f.f3.ni.fo.c7 .mqtt.f.f3.ni.fo.c8 .mqtt.f.f3.ni.fo.c9  -sticky news -padx 3
    grid .mqtt.f.f3.ni.fo -columnspan 3 -sticky ew -padx 5 -pady 5

    grid columnconfigure .mqtt.f.f3.ni.fo all -weight 1
    grid columnconfigure .mqtt.f.f3.ni all -weight 1
    grid rowconfigure .mqtt.f.f3.ni .mqtt.f.f3.ni.f -weight 1
   
    bind .mqtt.f.f3.ni.f.tv <<TreeviewSelect>> {cfg_devicesel %W}
    bind .mqtt.f.f3.ni.f.tv <Double-1> {cfg_device_dbl %W %x %y}
    destroy .rtclkMenuint
    set m [menu .rtclkMenuint]
    $m add command -label "Off" -command {cfg_rtclkdlg Off x10}
    $m add command -label "On" -command {cfg_rtclkdlg On x10}
    $m add command -label "Toggle" -command {cfg_rtclkdlg Toggle x10}
    $m add command -label "State" -command {cfg_rtclkdlg State x10}
    $m add command -label "Set To" -command {cfg_rtclkdlg setto x10}
    bind .mqtt.f.f3.ni.f.tv <Button-3> {cfg_rtclk x10 %W %x %y %X %Y}
    catch {.mqtt.f.f3.ni.f.tv tag configure red -foreground red}
    catch {.mqtt.f.f3.ni.f.tv tag configure black -foreground black}

    cfg_sortlist obj
    
    grid .mqtt.f.f3.ni -column 0 -columnspan 2 -sticky news -padx 3
    grid rowconfigure .mqtt.f.f3 .mqtt.f.f3.ni -weight 1
    grid columnconfigure .mqtt.f.f3 1 -weight 1
    grid .mqtt.f.f3 -sticky news  -padx 5 -pady 5
 
    if {[llength [lindex $cfg(listWidths) 1]] == 6} {
        foreach col {#0 #1 #2 #3 #4 #5} wid [lindex $cfg(listWidths) 1] {
            .mqtt.f.f3.ni.f.tv column $col -width $wid
        }
    }
    
    .mqtt.f add .mqtt.f.f3 -text "Int Objects" -underline 0

    # Settings Tab
    ttk::frame .mqtt.f.f2
    ttk::label .mqtt.f.f2.l17 -text "Command Prefix (<):"  -anchor e
    ttk::entry .mqtt.f.f2.e17 -width 10 -justify center -textvariable cfg(cmndPrefix)
    ttk::label .mqtt.f.f2.l18 -text "State Prefix (<):" -anchor e
    ttk::entry .mqtt.f.f2.e18 -width 10 -justify center -textvariable cfg(statPrefix)
    ttk::label .mqtt.f.f2.l19 -text "Tele Prefix (<):" -anchor e
    ttk::entry .mqtt.f.f2.e19 -width 10 -justify center -textvariable cfg(telePrefix)
    ttk::label .mqtt.f.f2.l20 -text "Power Postfix (>):" -anchor e
    ttk::entry .mqtt.f.f2.e20 -width 10 -justify center -textvariable cfg(pwrPostfix)
    ttk::label .mqtt.f.f2.l21 -text "LWT Postfix (>):" -anchor e
    ttk::entry .mqtt.f.f2.e21 -width 10 -justify center -textvariable cfg(LWTPostfix)
    ttk::label .mqtt.f.f2.l12 -text "MQTT Broker web/IP Address:" -anchor e
    ttk::entry .mqtt.f.f2.e12 -width 25 -justify center -textvariable cfg(broker)
    
    bind .mqtt.f <<NotebookTabChanged>> {.mqtt.f.f2.e17 selection clear; focus .mqtt.f.f2.e12; .mqtt.f.f2.e12 icursor end}
    
    ttk::label .mqtt.f.f2.l13 -text "MQTT Broker Port:" -anchor e
    ttk::entry .mqtt.f.f2.e13 -width 6 -justify center -textvariable cfg(brokerPort)
    ttk::label .mqtt.f.f2.l22 -text "Publish QOS:" -anchor e
    ttk::spinbox .mqtt.f.f2.e22 -width 3 -justify center -values {0 1 2} -textvariable cfg(publishQOS)
    ttk::label .mqtt.f.f2.l23 -text "Subscribe QOS:" -anchor e
    ttk::spinbox .mqtt.f.f2.e23 -width 3 -justify center -values {0 1 2} -textvariable cfg(subscribeQOS)
 
    ttk::label .mqtt.f.f2.l41 -text "Response uses \"OFF/ON\":" -anchor e
    ttk::label .mqtt.f.f2.l42 -text "Response uses \"0-100\":"  -anchor e
    ttk::label .mqtt.f.f2.l43 -text "Appliance Module" -anchor n
    ttk::label .mqtt.f.f2.l44 -text "All Others"       -anchor n
    ttk::radiobutton .mqtt.f.f2.r41 -variable cfg(appResponseType)   -value "1"
    ttk::radiobutton .mqtt.f.f2.r42 -variable cfg(appResponseType)   -value "0"
    ttk::radiobutton .mqtt.f.f2.r43 -variable cfg(otherResponseType) -value "1"
    ttk::radiobutton .mqtt.f.f2.r44 -variable cfg(otherResponseType) -value "0"

    ttk::checkbutton .mqtt.f.f2.c14 -text "Use Username/Password" -variable cfg(userpass) -command cfg_userpass
    ttk::label .mqtt.f.f2.l15 -text "Username:" -anchor e
    ttk::entry .mqtt.f.f2.e15 -width 25 -justify center -textvariable cfg(username)
    ttk::label .mqtt.f.f2.l16 -text "Password:" -anchor e
    ttk::entry .mqtt.f.f2.e16 -width 25 -justify center -textvariable cfg(password) -show *
    
    ttk::checkbutton .mqtt.f.f2.c31 -variable cfg(logging) -text "Create log file" -command cfg_logsel
    ttk::label .mqtt.f.f2.l31 -text "Log Folder:" -anchor e
    ttk::entry .mqtt.f.f2.e31  -textvariable cfg(logpath) -state readonly
    ttk::button .mqtt.f.f2.b31 -width 0 -text "..." -command [list sel_directory .mqtt cfg(logpath)]
    ttk::label .mqtt.f.f2.l33 -text "Log File Extension:" -anchor e
    ttk::entry .mqtt.f.f2.e33 -textvariable cfg(txtext)
      
    ttk::separator .mqtt.f.f2.sep
    
    ttk::label .mqtt.f.f2.l9 -text "Netio string:" -anchor e
    ttk::entry .mqtt.f.f2.e9 -width 10 -justify center -textvariable cfg(netioType)
    ttk::label .mqtt.f.f2.l10 -text "Serial string prefix string:" -anchor e
    ttk::entry .mqtt.f.f2.e10 -width 10 -justify center -textvariable cfg(serPre)
    ttk::label .mqtt.f.f2.l11 -text "Serial string terminator character(s):" -anchor e
    ttk::entry .mqtt.f.f2.e11 -width 5 -justify center -textvariable cfg(serPost)

    grid .mqtt.f.f2.l17 .mqtt.f.f2.e17 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l17     -sticky nes -padx 3
    grid .mqtt.f.f2.l18 .mqtt.f.f2.e18 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l18     -sticky nes -padx 3
    grid .mqtt.f.f2.l19 .mqtt.f.f2.e19 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l19     -sticky nes -padx 3
    grid .mqtt.f.f2.l20 .mqtt.f.f2.e20 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l20     -sticky nes -padx 3
    grid .mqtt.f.f2.l21 .mqtt.f.f2.e21 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l21     -sticky nes -padx 3
  
    grid .mqtt.f.f2.l12 .mqtt.f.f2.e12 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l12     -sticky nes -padx 3
    grid .mqtt.f.f2.l13 .mqtt.f.f2.e13 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l13     -sticky nes -padx 3
    grid .mqtt.f.f2.l22 .mqtt.f.f2.e22 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l22     -sticky nes -padx 3
    grid .mqtt.f.f2.l23 .mqtt.f.f2.e23 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l23     -sticky nes -padx 3

    grid x .mqtt.f.f2.l43 .mqtt.f.f2.l44 -sticky n -padx 3
    grid .mqtt.f.f2.l41 .mqtt.f.f2.r41 .mqtt.f.f2.r43 -sticky n
    grid configure .mqtt.f.f2.l41 -sticky nes -padx 3
    grid .mqtt.f.f2.l42 .mqtt.f.f2.r42 .mqtt.f.f2.r44 -sticky n 
    grid configure .mqtt.f.f2.l42 -sticky nes -padx 3

    grid x .mqtt.f.f2.c14  -sticky nws -padx 3    
    grid .mqtt.f.f2.l15 .mqtt.f.f2.e15 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l15     -sticky nes -padx 3
    grid .mqtt.f.f2.l16 .mqtt.f.f2.e16 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l16     -sticky nes -padx 3   
 
    grid x .mqtt.f.f2.c31 -sticky nws  -padx 3 -pady 1
    grid .mqtt.f.f2.l31 .mqtt.f.f2.e31 .mqtt.f.f2.b31 -sticky we -padx 3
    grid .mqtt.f.f2.l33 .mqtt.f.f2.e33 -sticky we -padx 3

    grid .mqtt.f.f2.sep -column 0 -columnspan 2 -sticky ew -padx 3 -pady 3

    grid .mqtt.f.f2.l9 .mqtt.f.f2.e9   -sticky nws -padx 3
    grid configure .mqtt.f.f2.l9      -sticky nes -padx 3
    grid .mqtt.f.f2.l10 .mqtt.f.f2.e10 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l10     -sticky nes -padx 3
    grid .mqtt.f.f2.l11 .mqtt.f.f2.e11 -sticky nws -padx 3
    grid configure .mqtt.f.f2.l11     -sticky nes -padx 3

    grid rowconfigure .mqtt.f.f2 all -weight 1
    grid columnconfigure .mqtt.f.f2 all -weight 1
    grid .mqtt.f.f2 -sticky news  -padx 5 -pady 5

    cfg_userpass    
    cfg_logsel
    
    .mqtt.f add .mqtt.f.f2 -text "Settings" -underline 0
   
    grid .mqtt.f    -sticky snew    -padx 5 -pady 5 -columnspan 3

    ttk::button .mqtt.b3 -text Done -width 8 -command cfg_done \
        -image [imglist ok] -compound left
    grid  .mqtt.b3  -columnspan 3 -padx {4 13} -pady {2 8} 
    grid columnconfigure .mqtt all -weight 1
    grid rowconfigure .mqtt .mqtt.f -weight 1
    grid rowconfigure .mqtt .mqtt.b3 -weight 0  
    
    if {[lindex $cfg(listWidths) 2]} {
        .mqtt.f select  [lindex $cfg(listWidths) 2]
    }
 
    wm protocol .mqtt WM_DELETE_WINDOW {.mqtt.b3 invoke}

    if {[regexp {\+-?[0-9]+\+-?[0-9]+} $cfg(geometry)]} {
        wm geometry .mqtt $cfg(geometry)
    }
    wm deiconify .mqtt
}

proc bindWidths {} {
    global cfg
    
    lset cfg(listWidths) 0 [lmap col {#0 #1 #2 #3 #4 #5} {.mqtt.f.f1.ni.f.tv column $col -width}]
    lset cfg(listWidths) 1 [lmap col {#0 #1 #2 #3 #4 #5} {.mqtt.f.f3.ni.f.tv column $col -width}]
    lset cfg(listWidths) 2 [.mqtt.f index current]
}

# Get images for Configuration dialog
proc imglist {i} {
    global img

    if {![info exists img($i)]} {
        set img($i) [image create photo \
            -file [file join [hvVariable ImagePath] $i.png]]
        set img([format %sdim $i]) [image create photo -format {png -alpha 0.3} \
            -file [file join [hvVariable ImagePath] $i.png]]
    }
    set dim $img([format %sdim $i])
    return [list $img($i) disabled $dim]
}

proc cfg_varflag {type} {
    global varflag vardbl
    
    if {$type in {obj ext}} {
        if {$varflag == 1} {
            .mqtt.usr.f1.xb2 state disabled
            .mqtt.usr.f1.xl2 state disabled
            set vardbl 0
        } else {
            .mqtt.usr.f1.xb2 state !disabled
            .mqtt.usr.f1.xl2 state !disabled
        }
    }
    
}

proc cfg_varflag_select {} {
    global mqttflag varlist vardbl
    
    if {$mqttflag > 255 && $mqttflag < 512} {
       set mqttid [expr {$mqttflag - 256}]
       grid x .mqtt.usr.f1
       if {$mqttid+1 == [hvObjectCount var]} {
           set varlist "(VA-[expr {$mqttid+1}] Not available.)"
           set vardbl 0
       } else {
            set varlist "(VA-$mqttid, VA-[expr {$mqttid+1}])"
       }
    } else {
       grid remove .mqtt.usr.f1  
    }
}

proc cfg_object_varflag_select {} {
    global mqttobj mqttid varlist vardbl
    
    if {$mqttobj eq "var"} {
       grid x .mqtt.usr.f1
       if {$mqttid+1 == [hvObjectCount var]} {
           set varlist "(VA-[expr {$mqttid+1}] Not available.)"
           set vardbl 0
       } else {
            set varlist "(VA-$mqttid, VA-[expr {$mqttid+1}])"
       }
    } else {
        grid remove .mqtt.usr.f1
    }
}

proc cfg_logsel {} {
    global cfg

    if {$cfg(logging)} {
         grid .mqtt.f.f2.l31 .mqtt.f.f2.e31 .mqtt.f.f2.b31 -sticky we -padx 3
         grid .mqtt.f.f2.l33 .mqtt.f.f2.e33 -sticky we -padx 3
    } else {
        grid remove .mqtt.f.f2.l31 .mqtt.f.f2.e31 .mqtt.f.f2.b31
        grid remove .mqtt.f.f2.l33 .mqtt.f.f2.e33
    }
}

proc sel_directory {top name} {
    upvar #0 $name var
    set dir [ttk::chooseDirectory -initialdir $var -mustexist 1 \
      -parent $top -title "Select directory"]
    if {$dir ne ""} {set var $dir}
}

proc cfg_userpass {} {
    global cfg
    
    if {$cfg(userpass)} {
        grid .mqtt.f.f2.l15 .mqtt.f.f2.e15
        grid .mqtt.f.f2.l16 .mqtt.f.f2.e16
    } else {
        grid remove .mqtt.f.f2.l15 .mqtt.f.f2.e15
        grid remove .mqtt.f.f2.l16 .mqtt.f.f2.e16
    }
}

proc cfg_devicesel {w} {
   set p [winfo parent [winfo parent $w]]
    if {[llength [$w selection]]} {
        $p.b1 state !disabled
        $p.b3 state !disabled
    } else {
        $p.b1 state disabled
        $p.b3 state disabled
    }
}

# Double-click enters edit mode
proc cfg_device_dbl {w x y} {
    # Use identify row instead of item for compatibility with 8.5.8 and 8.5.9
   set p [winfo parent [winfo parent $w]]
    if {[$w identify row $x $y] ne ""} {
        $p.b1 invoke
    }
}

# put up device right-click menu
proc cfg_rtclk {type w x y X Y} {
    global objtypes
    
    set item [$w identify item $x $y]
    if {$item ne ""} {
        $w selection set $item
        if {$type eq "ext"} {
        tk_popup .rtclkMenu $X $Y
        } else {
            set win .mqtt.f.f3.ni.f.tv
            set item [lindex [$win selection] 0]
            lassign [$win item $item -values] name topic state id tp
            dict for {obj info} $objtypes {
                dict with info {
                    if {$tp == $order} {
                        break
                    }
                }
            }
            if {[dict get $objtypes $obj off] eq ""} {
                .rtclkMenuint entryconfigure  0 -state disabled 
            } else {
                .rtclkMenuint entryconfigure  0 -state normal 
            }
            if {[dict get $objtypes $obj on] eq ""} {
                .rtclkMenuint entryconfigure  1 -state disabled 
            } else {
                .rtclkMenuint entryconfigure  1 -state normal 
            }
            if {[dict get $objtypes $obj toggle] eq ""} {
                .rtclkMenuint entryconfigure  2 -state disabled 
            } else {
                .rtclkMenuint entryconfigure  2 -state normal 
            }
            if {[dict get $objtypes $obj state] eq ""} {
                .rtclkMenuint entryconfigure  3 -state disabled 
            } else {
                .rtclkMenuint entryconfigure  3 -state normal 
            }
            if {[dict get $objtypes $obj setto] eq ""} {
                .rtclkMenuint entryconfigure  4 -state disabled 
            } else {
                .rtclkMenuint entryconfigure  4 -state normal 
            }
            tk_popup .rtclkMenuint $X $Y
    }
    }
}

# process command selected in right-click menu
proc cfg_rtclkdlg {cmd {type ext}} {
    global objtypes
    
    if {$type eq "x10"} {
        set win .mqtt.f.f3.ni.f.tv
    set item [lindex [$win selection] 0]
    lassign [$win item $item -values] name topic state id tp
    dict for {obj info} $objtypes {
        dict with info {
            if {$tp == $order} {
                    if {$cmd eq "setto"} {
                        set cmd ""
                        cfg_rtclksettodlg $obj
                    } else {
                    set cmd [set [string tolower $cmd]]
            }
                    break
                }
        }
    }
    } else {
        set win .mqtt.f.f1.ni.f.tv
        set item [lindex [$win selection] 0]
        lassign [$win item $item -values] name
    }
    if {$cmd ne ""} {
        sendCmd $name [createCmd $cmd]
    }
}

proc cfg_rtclksettodlg {obj} {
    global setto
    
    ttk::toplevel .mqtt.st
    wm title .mqtt.st "Configure Device"
    wm transient .mqtt.st .mqtt
    wm withdraw .mqtt.st
    
    ttk::frame .mqtt.st.f1
    ttk::label .mqtt.st.f1.l1 -text "Set to Value:" -anchor w
    ttk::entry .mqtt.st.f1.e1 -width 5 -textvariable setto
    ttk::frame .mqtt.st.f
    ttk::button .mqtt.st.f.b1 -text OK -width 6 -command [list cfg_rtclksetto $obj] \
        -image [imglist ok] -compound left
    ttk::button .mqtt.st.f.b2 -text Cancel -width 6 -command {destroy .mqtt.st} \
        -image [imglist cancel] -compound left
    grid .mqtt.st.f1.l1   .mqtt.st.f1.e1   -padx 4  -pady 1 -sticky we
    grid configure    .mqtt.st.f1.l1    -padx 3  -sticky nes
    grid .mqtt.st.f1         -       -padx 4  -pady 3 -sticky we
    grid .mqtt.st.f.b1 .mqtt.st.f.b2 -padx 20 -pady 4
    grid .mqtt.st.f         -       -padx 4  -pady 3 -sticky we
    grid anchor .mqtt.st.f1 center
    grid anchor .mqtt.st.f center
    bind .mqtt.st.f1.e1 <Return> {.mqtt.st.f.b1 invoke}
    bind .mqtt.st <F1> {hvHelp users}
    center .mqtt.st .mqtt
    grab .mqtt.st
    focus .mqtt.st.f1.e1
}

proc cfg_rtclksetto {obj} {
    global setto
    
    if {[string is integer -strict $setto] || [string is double -strict $setto] } {
        set win .mqtt.f.f3.ni.f.tv
        set item [lindex [$win selection] 0]
        lassign [$win item $item -values] name
        sendCmd $name $setto
    }
    destroy .mqtt.st
}

proc cfg_validate_cmnd {str} {
    global mqtttopic mqttcmnd
    if {[string length $str] >= 1} {
        if {[regexp {^\w+$} $str]} {
            .mqtt.usr.l4 state disabled
            .mqtt.usr.cb state disabled
            .mqtt.usr.l5 state disabled
            .mqtt.usr.cb5 state disabled
            .mqtt.usr.l6 state disabled
            .mqtt.usr.cb6 state disabled
            .mqtt.usr.f1.xb1 state disabled
            .mqtt.usr.f1.xb2 state disabled
            cfg_validate $mqtttopic topic mqttname
            return 1
        }
    } elseif {[string length $str] == 0} {
        .mqtt.usr.l4 state !disabled
        .mqtt.usr.cb state !disabled
        .mqtt.usr.l5 state !disabled
        .mqtt.usr.cb5 state !disabled
        .mqtt.usr.l6 state !disabled
        .mqtt.usr.cb6 state !disabled
        .mqtt.usr.f1.xb1 state !disabled
        .mqtt.usr.f1.xb2 state !disabled
        set mqttcmnd ""
        cfg_validate $mqtttopic topic mqttname
        return 1
    }
    return 0
}

proc cfg_validate {str type var} {
    upvar #0 $var other
    
    if {$type eq "name"} {
        set otype "topic"
    } else {
        set otype "name"
    }
    if {[cfg_validate_$type $str] && [cfg_validate_$otype $other]} {
        .mqtt.usr.f.b1 state !disabled
    } else {
        .mqtt.usr.f.b1 state disabled
    }
    return 1
}

proc cfg_validate_name {str} {
    if {[string length $str] >= 1} {
        if {$str ne {pub sub unsub}} {
            if {[regexp {^\w+$} $str]} {
                return 1
            }
        }
    }
    return 0
}

proc cfg_validate_topic {str} {
    if {[string length $str] >= 1} {
        if {[cfg_validate_slash $str]} {
            if {[cfg_validate_hash $str]} {
                if {[cfg_validate_plus $str]} {
                    return 1
               }
           }
        }
    }
    return 0
}

proc cfg_validate_slash {str} {
    set tstr [string trim $str /]
    set tl [string length $tstr]
    if {[string length $str] != $tl} {return 0}
    for {set i 1} {$i < $tl} {incr i} {
        if {[string index $tstr $i] ne "/"} {continue}
        if {[string index $tstr $i+1] eq "/"} {return 0}
    }
    return 1
}

proc cfg_validate_hash {str} {
    global mqttcmnd
    set idx [string first {#} $str]
    if {$idx == -1} {return 1}
    # hash only allowed when cmnd is set
    if {[string length $mqttcmnd] < 1 || ![regexp {^\w+$} $mqttcmnd]} {return 0}
    set sl [string length $str]
    if {$sl == 1} {return 1}
    if {$sl == $idx+1 && $sl > 2 && [string index $str $idx-1] eq "/"} {return 1}
    debug "hash Fail:$str;$idx;" red
    return 0
}

proc cfg_validate_plus {str} {
    global mqttcmnd    
    set idx [regexp -all -inline -indices {\+} $str]
    if {$idx eq ""} {return 1}
    # + only allowed when cmnd is set
    if {[string length $mqttcmnd] < 1 || ![regexp {^\w+$} $mqttcmnd]} {return 0}
    set sl [string length $str]
    set pass 1
    foreach i $idx {
        set j [lindex $i 0]
        if {$j == 0} {
            if {$sl == 1} {
                continue
            } elseif {[string index $str 1] eq "/"} {continue}
            set pass 0
        } elseif {$j == $sl-1} {
            if {[string index $str $j-1] eq "/"} {continue}
            set pass 0
        } else {
            if {[string index $str $j-1] eq "/" && [string index $str $j+1] eq "/"} {continue}
            set pass 0
        }
    }
    return $pass
}

proc cfg_device_add {} {
    global mqttname mqtttopic mqttstate mqttflag mqttmacro_on mqttmacro_off mqttid mqttcmnd mqttlwt varflag vardbl logrx logtx

    if {$mqttname eq "" || $mqtttopic eq ""} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Topic and Name must be supplied"
        return
    }
    if {[llength [mk::select cfg.x10 -exact name $mqttname]]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Int)"
        return
    }
    if {[llength [mk::select cfg.devices -exact name $mqttname]]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Ext)"
        return
    }
 
    if {$mqttflag == 512} {
        set flag "-"
    } else {
        if {$mqttflag > 255} {
            set flag VA-[expr {$mqttflag - 256}]
        } else {
            set flag FL-$mqttflag
        }
    }
    set macro [expr {$mqttmacro_on < 256?$mqttmacro_on:"-"}]/[expr {$mqttmacro_off < 256?$mqttmacro_off:"-"}]

    mk::row append cfg.devices name $mqttname topic $mqtttopic \
        state $mqttstate status 0 flag $mqttflag \
        macro_on $mqttmacro_on macro_off $mqttmacro_off \
        cmnd $mqttcmnd lwt $mqttlwt \
        varflag [expr {$varflag | ($vardbl<<1)}] loglevel [expr {$logrx | ($logtx<<1)}]
    
    .mqtt.f.f1.ni.f.tv insert {} end -values [list $mqttname $mqtttopic $mqttstate $flag $macro] -tags black
    destroy .mqtt.usr
    cfg_sortlist ext
}

proc cfg_object_add {} {
    global mqttname mqtttopic mqttstate mqttid mqttobj x10types objtypes varflag vardbl logrx logtx retain

    if {$mqttname eq "" || $mqtttopic eq ""} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Topic and Name must be supplied"
        return
    }
    if {[llength [mk::select cfg.x10 -exact name $mqttname]]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Int)"
        return
    }
    if {[llength [mk::select cfg.devices -exact name $mqttname]]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Ext)"
        return
    }
    
    set mqttmodel ""
    set type [dict get $objtypes $mqttobj order]
    if {$mqttobj eq "x10"} {
        set mqttmodel [lindex [dict keys $x10types] [.mqtt.usr.c3 current]]
        set id [string map {" " -} [hvObjectId x10 $mqttid]]
    } elseif {$mqttobj in {input output}} {
        set id [string toupper [string index $mqttobj 0]][hvObjectId $mqttobj $mqttid]
    } else {
        set id "[string toupper [string range $mqttobj 0 1]]-$mqttid"
    }
    if {$mqttobj eq "light"} {
        set mqttmodel "light"
    }
    
    if {$mqttobj eq "hvac"} {
        lassign [hvObjectState $mqttobj $mqttid] newstate newlevel mqttmodel
    } else {
        lassign [hvStateString $mqttobj $mqttid] newstate newlevel
        if {$mqttobj in {var temp}} {
            set newlevel $newstate       
            set newstate "-"
        } elseif {$mqttobj eq "flag"} {
            set newlevel "-"
        } elseif {$mqttobj in {input output}} {
            set os [hvObjectState $mqttobj $mqttid]
            if {$os ne ""} {
                set newstate [hvObjectLabel $mqttobj $mqttid $os]
            } else {
                set newstate "Unknown"
            }
            set newlevel "-"
        }
    }
  
    mk::row append cfg.x10 id $mqttid name $mqttname topic $mqtttopic state $newstate level $newlevel type $type model $mqttmodel object $mqttobj varflag [expr {$varflag | ($vardbl<<1)}] loglevel [expr {$logrx | ($logtx<<1)}] retain $retain

    .mqtt.f.f3.ni.f.tv insert {} end -values [list $mqttname $mqtttopic $mqttstate $id $type $newlevel] -tags black
    destroy .mqtt.usr
    cfg_sortlist obj
}

proc cfg_device_addnew {type} {
    global mqttname mqtttopic mqttstate mqttflag mqttmacro_on mqttmacro_off mqttid mqttobj mqttvarflag varflag mqttvardbl vardbl mqttloglevel logrx logtx mqttretain retain mqttcmnd cmnd mqttlwt lwt

    set mqttname ""
    set mqtttopic ""
    set mqttstate "-"
    set mqttflag "512"
    set mqttid "256"
    set mqttmacro_on "256"
    set mqttmacro_off "256"
    set mqttobj ""

    set mqttcmnd ""
    set cmnd ""
    set mqttlwt 0
    set lwt 0
    set mqttvarflag 1
    set varflag 1
    set mqttvardbl 0
    set vardbl 0
    set mqttloglevel 0
    set logrx 0
    set logtx 0
    set mqttretain 0
    set retain 0
    
    if {$type eq "obj"} {
        cfg_object_adddlg
    } else {
        cfg_device_adddlg
    }
}

proc cfg_device_adddlg {} {
    global mqttname mqtttopic mqttvarflag varflag mqttvardbl mqttcmnd cmnd mqttlwt lwt vardbl mqttloglevel logrx logtx
    
    set row [mk::select cfg.devices name $mqttname]
    if {$row ne ""} {
        lassign [mk::get cfg.devices!$row varflag loglevel cmnd lwt] varflag loglevel cmnd lwt
        set vardbl [expr {($varflag & 0x02)>>1}]
        set mqttvardbl $vardbl
        set varflag [expr {$varflag & 0x01}]
        set mqttvarflag $varflag
        set mqttloglevel $loglevel
        set logtx [expr {($loglevel & 0x02)>>1}]
        set logrx [expr {$loglevel & 0x01}]
        set mqttcmnd $cmnd
        set mqttlwt $lwt
    }

    ttk::toplevel .mqtt.usr
    wm title .mqtt.usr "Configure Device"
    wm transient .mqtt.usr .mqtt
    wm withdraw .mqtt.usr
    ttk::label .mqtt.usr.l1 -text "Name:" -anchor w
    ttk::entry .mqtt.usr.e1 -width 20 -textvariable mqttname \
      -validate all -validatecommand "cfg_validate %P name mqtttopic"
    ttk::label .mqtt.usr.l2 -text "Topic:" -anchor w
    ttk::entry .mqtt.usr.e2 -width 40 -textvariable mqtttopic \
      -validate all -validatecommand "cfg_validate %P topic mqttname"
    ttk::label .mqtt.usr.l4 -text "Flag/Var:" -anchor w
    ttk::combobox .mqtt.usr.cb -state readonly -width 28
    bind .mqtt.usr.cb <<ComboboxSelected>> [list cfg_flag_set .mqtt.usr.cb]
    createflaglist .mqtt.usr.cb
    ttk::frame .mqtt.usr.f1
    ttk::checkbutton .mqtt.usr.f1.xb1 -text "Use Variable as flag" -command {cfg_varflag ext} -variable varflag
    ttk::checkbutton .mqtt.usr.f1.xb2 -text "Use two Variables" -command {cfg_varflag dbl} -variable vardbl
    ttk::label .mqtt.usr.f1.xl2 -textvariable varlist -anchor w
    ttk::label .mqtt.usr.l5 -text "On Macro:" -anchor w
    ttk::combobox .mqtt.usr.cb5 -state readonly -width 28
    bind .mqtt.usr.cb5 <<ComboboxSelected>> [list cfg_macro_set .mqtt.usr.cb5 mqttmacro_on]
    createmacrolist .mqtt.usr.cb5 mqttmacro_on
    ttk::label .mqtt.usr.l6 -text "Off Macro:" -anchor w
    ttk::combobox .mqtt.usr.cb6 -state readonly -width 28
    bind .mqtt.usr.cb6 <<ComboboxSelected>> [list cfg_macro_set .mqtt.usr.cb6 mqttmacro_off]
    createmacrolist .mqtt.usr.cb6 mqttmacro_off
    ttk::label .mqtt.usr.l7 -text "Command:" -anchor w
    ttk::entry .mqtt.usr.e7 -width 20 -textvariable mqttcmnd \
      -validate all -validatecommand "cfg_validate_cmnd %P"
    ttk::button .mqtt.usr.b3 -text "Copy Topic to Name"  -command cfg_topic_copy \
        -image [imglist copy] -compound left
    ttk::frame .mqtt.usr.f2
    ttk::checkbutton .mqtt.usr.f2.xb5 -text "Subscribe to Last WIll & Testament" -variable mqttlwt
    ttk::checkbutton .mqtt.usr.f2.xb3 -text "Log received messages" -variable logrx
    ttk::checkbutton .mqtt.usr.f2.xb4 -text "Log sent messages" -variable logtx
    ttk::separator .mqtt.usr.sep
    ttk::frame .mqtt.usr.f
    ttk::button .mqtt.usr.f.b1 -text OK -width 6 -command cfg_device_add -state disabled \
        -image [imglist ok] -compound left
    ttk::button .mqtt.usr.f.b2 -text Cancel -width 6 -command {destroy .mqtt.usr;cfg_sortlist ext} \
        -image [imglist cancel] -compound left
    grid .mqtt.usr.f.b1 .mqtt.usr.f.b2 -padx 20 -pady 4
    grid anchor .mqtt.usr.f center
    grid .mqtt.usr.f1.xb1 -padx 4 -pady 1 -sticky w
    grid .mqtt.usr.f1.xb2 .mqtt.usr.f1.xl2 -padx 4 -pady 1 -sticky w
    grid .mqtt.usr.l2   .mqtt.usr.e2  -padx 4 -pady 1 -sticky we
    grid       x       .mqtt.usr.b3  -padx 4 -pady 1
    grid .mqtt.usr.l1   .mqtt.usr.e1  -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.l4   .mqtt.usr.cb  -padx 4 -pady 1 -sticky we
    grid       x        .mqtt.usr.f1  -sticky w
    grid .mqtt.usr.l5   .mqtt.usr.cb5 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.l6   .mqtt.usr.cb6 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.l7   .mqtt.usr.e7 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.f2.xb5 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.f2.xb3 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.f2.xb4 -padx 4 -pady 1 -sticky we
    grid       x      .mqtt.usr.f2 -sticky w
    grid .mqtt.usr.sep - -padx 2 -pady {2 0} -sticky we
    grid .mqtt.usr.f - -padx 4 -pady 3 -sticky we
    grid columnconfigure .mqtt.usr .mqtt.usr.e2 -weight 1
    bind .mqtt.usr.e2 <Return> {.mqtt.usr.f.b1 invoke}
    bind .mqtt.usr <F1> {hvHelp users}
    center .mqtt.usr .mqtt
    grab .mqtt.usr
    focus .mqtt.usr.e2
    cfg_varflag_select
    cfg_varflag ext
}

proc cfg_object_adddlg {} {
    global mqttname mqtttopic mqttid mqttobj x10types mqttvarflag varflag mqttvardbl vardbl mqttloglevel logrx logtx mqttretain retain

    set row [mk::select cfg.x10 name $mqttname]
    if {$row ne ""} {
        lassign [mk::get cfg.x10!$row varflag loglevel retain] varflag loglevel mqttretain
        set vardbl [expr {($varflag & 0x02)>>1}]
        set mqttvardbl $vardbl
        set varflag [expr {$varflag & 0x01}]
        set mqttvarflag $varflag
        set mqttloglevel $loglevel
        set logtx [expr {($loglevel & 0x02)>>1}]
        set logrx [expr {$loglevel & 0x01}]
        set retain $mqttretain
    }

    ttk::toplevel .mqtt.usr
    wm title .mqtt.usr "Configure Object"
    wm transient .mqtt.usr .mqtt
    wm withdraw .mqtt.usr
    ttk::label .mqtt.usr.l1 -text "Name:" -anchor w
    ttk::entry .mqtt.usr.e1 -width 20 -textvariable mqttname \
      -validate all -validatecommand "cfg_validate %P name mqtttopic"
    ttk::label .mqtt.usr.l3 -text "Model:"
    ttk::combobox .mqtt.usr.c3 -state readonly -width 40 \
      -values [dict values $x10types]
    ttk::label .mqtt.usr.l2 -text "Topic:" -anchor w
    ttk::entry .mqtt.usr.e2 -width 40 -textvariable mqtttopic \
      -validate all -validatecommand "cfg_validate %P topic mqttname"
    ttk::label .mqtt.usr.l4 -text "Object:" -anchor w
    ttk::combobox .mqtt.usr.cb -state readonly -width 28
    bind .mqtt.usr.cb <<ComboboxSelected>> [list cfg_object_set .mqtt.usr.cb mqttid mqttobj]
    createobjlist .mqtt.usr.cb $mqttobj
    ttk::frame .mqtt.usr.f1
    ttk::checkbutton .mqtt.usr.f1.xb1 -text "Use Variable as flag" -command {cfg_varflag obj} -variable varflag
    ttk::checkbutton .mqtt.usr.f1.xb2 -text "Use two Variables" -command {cfg_varflag dbl} -variable vardbl
    ttk::label .mqtt.usr.f1.xl2 -textvariable varlist -anchor w
    
    ttk::button .mqtt.usr.b3 -text "Copy Object to Topic, Name"  -command cfg_object_copy \
        -image [imglist copy] -compound left
    ttk::frame .mqtt.usr.f2
    ttk::checkbutton .mqtt.usr.f2.xb3 -text "Log received messages" -variable logrx
    ttk::checkbutton .mqtt.usr.f2.xb4 -text "Log sent messages" -variable logtx
    ttk::checkbutton .mqtt.usr.f2.xb5 -text "Set Retain flag" -variable retain
    ttk::separator .mqtt.usr.sep
    ttk::frame .mqtt.usr.f
    ttk::button .mqtt.usr.f.b1 -text OK -width 6 -command cfg_object_add -state disabled \
        -image [imglist ok] -compound left    
    ttk::button .mqtt.usr.f.b2 -text Cancel -width 6 -command {destroy .mqtt.usr;cfg_sortlist obj} \
        -image [imglist cancel] -compound left    
    set row [mk::select cfg.x10 name $mqttname]
    if {![catch {mk::get cfg.x10!$row model} model] && $model ne ""} {
        if {[mk::get cfg.x10!$row object] in {x10 light}} {
            .mqtt.usr.c3 set [dict get $x10types [mk::get cfg.x10!$row model]]
        } else {
            .mqtt.usr.c3 current 0
        }
    } else {
	    .mqtt.usr.c3 current 0
    }
    grid .mqtt.usr.f.b1 .mqtt.usr.f.b2 -padx 20 -pady 4
    grid anchor .mqtt.usr.f center
    grid .mqtt.usr.f1.xb1 -padx 4 -pady 1 -sticky w
    grid .mqtt.usr.f1.xb2 .mqtt.usr.f1.xl2 -padx 4 -pady 1 -sticky w
    grid .mqtt.usr.l4 .mqtt.usr.cb -padx 4 -pady 1 -sticky we
    grid  x .mqtt.usr.f1 -padx 4 -pady 1
    grid .mqtt.usr.l3 .mqtt.usr.c3 -padx 4 -pady 1 -sticky we
    grid  x .mqtt.usr.b3  -padx 4 -pady 1 
    grid .mqtt.usr.l2 .mqtt.usr.e2 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.l1 .mqtt.usr.e1 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.f2.xb5 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.f2.xb3 -padx 4 -pady 1 -sticky we
    grid .mqtt.usr.f2.xb4 -padx 4 -pady 1 -sticky we
    grid       x      .mqtt.usr.f2 -sticky w
    grid .mqtt.usr.sep - -padx 2 -pady {2 0} -sticky we
    grid .mqtt.usr.f - -padx 4 -pady 3 -sticky we
    grid columnconfigure .mqtt.usr .mqtt.usr.e2 -weight 1
    bind .mqtt.usr.e2 <Return> {.mqtt.usr.f.b1 invoke}
    bind .mqtt.usr <F1> {hvHelp users}
    center .mqtt.usr .mqtt
    grab .mqtt.usr
    focus .mqtt.usr.l2
    cfg_varflag obj
    cfg_object_varflag_select
}

proc cfg_device_chgdlg {} {
    global mqttname mqtttopic mqttstate mqttflag mqttmacro_on mqttmacro_off mqttvarflag varflag mqttcmnd mqttlwt

    set item [lindex [.mqtt.f.f1.ni.f.tv selection] 0]
    lassign [.mqtt.f.f1.ni.f.tv item $item -values] mqttname mqtttopic mqttstate c macro
    set row [mk::select cfg.devices -exact name $mqttname]
    set mqttcmnd [mk::get cfg.devices!$row cmnd]
    set mqttlwt [mk::get cfg.devices!$row lwt]
    if {$c eq "-"} {
        set mqttflag 512
    } else {
        lassign [split $c {-}] grp num
        if {$grp eq "VA"} {
            set mqttflag [expr {$num + 256}]
        } else {
            set mqttflag $num
        }
    }
     lassign [split $macro /] mqttmacro_on mqttmacro_off
    if {$mqttmacro_on eq "-"} {
        set mqttmacro_on 256
    } 
    if {$mqttmacro_off eq "-"} {
        set mqttmacro_off 256
    } 
    cfg_device_adddlg
    .mqtt.usr.f.b1 configure -command [list cfg_device_chg $item]
    cfg_validate $mqtttopic topic mqttname
    cfg_validate_cmnd $mqttcmnd
}

proc cfg_object_chgdlg {} {
    global mqttname mqtttopic mqttstate mqttid mqttobj varflag vardbl

    set item [lindex [.mqtt.f.f3.ni.f.tv selection] 0]
    lassign [.mqtt.f.f3.ni.f.tv item $item -values] mqttname mqtttopic mqttstate c type
    if {$c eq "None" || $c eq "-"} {
        set mqttid 256
        set mqttobj ""
    } else {
        lassign [split $c {-}] grp num
        if {$grp eq "LI"} {
            set mqttid $num
            set mqttobj "light"
        } elseif {$grp eq "FL"} {
            set mqttid $num
            set mqttobj "flag"
        } elseif {$grp eq "VA"} {
            set mqttid $num
            set mqttobj "var"
        } elseif {$grp eq "HV"} {
            set mqttid $num
            set mqttobj "hvac"
        } elseif {$grp eq "TE"} {
            set mqttid $num
            set mqttobj "temp"
        } elseif {$grp eq "AN"} {
            set mqttid $num
            set mqttobj "analog"
        } elseif {[regexp {^I[A-Q]$} $grp]} {
            set mqttid [getid input [string index $grp 1] $num]
            set mqttobj "input"
        } elseif {[regexp {^O[A-Q]$} $grp]} {
            set mqttid [getid output [string index $grp 1] $num]
            set mqttobj "output"
        } else {
        set mqttid [expr {(([scan $grp %c] - 65)*16) + $num - 1}]
            set mqttobj "x10"
    }    
    }
    cfg_object_adddlg
    .mqtt.usr.f.b1 configure -command [list cfg_object_chg $item]
    cfg_validate $mqtttopic topic mqttname
}

proc cfg_device_chg {item} {
    global mqttname mqtttopic mqttstate mqttflag mqttmacro_on mqttmacro_off mqttcmnd cmnd mqttlwt lwt mqttvarflag varflag mqttvardbl vardbl mqttloglevel logrx logtx

    lassign [.mqtt.f.f1.ni.f.tv item $item -values] name topic state c macro
    set row [mk::select cfg.devices -exact name $name]
    set cmnd [mk::get cfg.devices!$row cmnd]
debug "$name,$mqttname;$cmnd" blue
    if {$c eq "-"} {
        set flag 512
    } else {
        lassign [split $c {-}] grp num
        if {$grp eq "VA"} {
            set flag [expr {$num + 256}]
        } else {
            set flag $num
        }
    }
    lassign [split $macro /] macro_on macro_off
    if {$macro_on eq "-"} {
        set macro_on 256
    } 
     if {$macro_off eq "-"} {
        set macro_off 256
    } 
    
    set row [mk::select cfg.devices -exact name $name]
    if {$mqttname eq $name && $mqtttopic eq $topic \
         && $mqttstate eq $state && $mqttflag eq $flag \
         && $mqttmacro_on eq $macro_on && $mqttmacro_off eq $macro_off \
         && $mqttcmnd eq $cmnd && $mqttlwt eq $lwt \
         && $mqttvarflag eq $varflag && $mqttvardbl eq $vardbl \
         && $mqttloglevel eq ($logrx | $logtx<<1)} {
        debug "Nothing changed"
        destroy .mqtt.usr
        cfg_sortlist ext
        return
    } 
        if {[llength [mk::select cfg.devices -exact name $mqttname]] &&  \
             $row != [mk::select cfg.devices -exact name $mqttname]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Ext)"
            return
        }
    if {[llength [mk::select cfg.x10 -exact name $mqtttopic]]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Topic $mqtttopic already exists (Int)"
            return
        }

    if {$mqttflag == 512} {
        set flag "-"
    } else {
        if {$mqttflag > 255} {
            set flag VA-[expr {$mqttflag - 256}]
        } else {
            set flag FL-$mqttflag
        }
    }
    set macro [expr {$mqttmacro_on < 256?$mqttmacro_on:"-"}]/[expr {$mqttmacro_off < 256?$mqttmacro_off:"-"}]

    if {$cmnd eq ""} {
        set cmnd "subrecv"
    } else {
        set cmnd Custom_$cmnd
    }
    if {[regexp {^<.+>[1-9]?$} $topic] && ($lwt && ($lwt ne $mqttlwt || $cmnd ne $mqttcmnd || $topic ne $mqtttopic))} {
        # lwt changed to off and/or topic or callback changed, only for standard topics
        sendMqtt unsub tele $topic LWT $cmnd
    }
    if {$cmnd ne $mqttcmnd || $topic ne $mqtttopic} {
        # the topic and/or callback changed, unsub from original.
        if {[regexp {^.+>[1-9]?$} $topic]} {
            # unsubscribe to rst only if default postfix
            sendMqtt unsub stat $topic rst $cmnd
        }
        sendMqtt unsub stat $topic pwr $cmnd
    }
    
    mk::set cfg.devices!$row name $mqttname topic $mqtttopic  status 0 flag $mqttflag  macro_on $mqttmacro_on macro_off $mqttmacro_off varflag [expr {$varflag | ($vardbl<<1)}] loglevel [expr {$logrx | ($logtx<<1)}] cmnd $mqttcmnd lwt $mqttlwt
    
    .mqtt.f.f1.ni.f.tv item $item -values [list $mqttname $mqtttopic $mqttstate $flag $macro] -tags black
    destroy .mqtt.usr
    cfg_sortlist ext
}

proc cfg_object_chg {item} {
    global mqttname mqtttopic mqttstate mqttid mqttmodel mqttobj x10types objtypes mqttvarflag varflag mqttvardbl vardbl mqttloglevel logrx logtx mqttretain retain

    lassign [.mqtt.f.f3.ni.f.tv item $item -values] name topic state c type level
    if {$c eq "None" || $c eq "-"} {
        set id 256
    } else {
    lassign [split $c {-}] grp num
        set id $num
        set mqttmodel ""
        if {$grp eq "LI"} {
            set mqttmodel "light"
        } elseif {[regexp {^I[A-Q]$} $grp]} {
            set id [getid input [string index $grp 1] $num]
        } elseif {[regexp {^O[A-Q]$} $grp]} {
            set id [getid output [string index $grp 1] $num]
        } elseif {[string match {[A-P]} $grp]} {
    set id [expr {(([scan $grp %c] - 65)*16) + $num - 1}]
            set mqttmodel [lindex [dict keys $x10types] [.mqtt.usr.c3 current]]
        }
    }

    set row [mk::select cfg.x10 -exact name $name]
    if {![catch {mk::get cfg.x10!$row model}]} {
        set model [mk::get cfg.x10!$row model]
    } else {
        set model ""
    }
    if {$mqttname eq $name && $mqtttopic eq $topic && $mqttid eq $id \
        && $mqttmodel eq $model \
        && $mqttvarflag eq $varflag && $mqttvardbl eq $vardbl \
        && $mqttloglevel eq ($logrx | $logtx<<1) \
        && $mqttretain eq $retain} {
        debug "Nothing changed"
        destroy .mqtt.usr
        cfg_sortlist obj
        return
    }
        if {[llength [mk::select cfg.x10 -exact name $mqttname]] &&  \
             $row != [mk::select cfg.x10 -exact name $mqttname]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Int)"
            return
        }
    if {[llength [mk::select cfg.devices -exact name $mqttname]]} {
        ttk::messageBox -parent .mqtt.usr -icon error -type ok \
          -message "Name $mqttname already exists (Ext)"
        return
    }

        if {$mqttobj eq "x10"} {
        set mqttmodel [lindex [dict keys $x10types] [.mqtt.usr.c3 current]]
        set id [string map {" " -} [hvObjectId x10 $mqttid]]
        } else {
            set mqttmodel ""
            set id "[string toupper [string range $mqttobj 0 1]]-$mqttid"
    }
            set type [dict get $objtypes $mqttobj order]
            set object $mqttobj
    if {$mqttobj eq "light"} {
        set mqttmodel "light"
    }

    mk::set cfg.x10!$row id $mqttid name $mqttname topic $mqtttopic type $type model $mqttmodel object $object varflag [expr {$varflag | ($vardbl<<1)}] loglevel [expr {$logrx | ($logtx<<1)}] retain $retain

    .mqtt.f.f3.ni.f.tv item $item -values [list $mqttname $mqtttopic $mqttstate $id $type $level] -tags black
    destroy .mqtt.usr
    cfg_sortlist obj
}

proc cfg_device_del {type} {
    global mymqtt

    if {$type eq "x10"} {
        set win .mqtt.f.f3.ni.f.tv
    } else {
        set win .mqtt.f.f1.ni.f.tv
        set type "devices"
    }
    set name [$win set [$win selection] name]
    set row [mk::select cfg.$type -exact name $name]
    lassign [mk::get cfg.$type!$row topic cmnd lwt] topic cmnd lwt
    if {$type eq "x10"} {
        sendMqtt unsub cmnd $topic pwr subrecv
    } else {
        if {$cmnd eq ""} {
                set cmnd "subrecv"
        } else {
            set cmnd Custom_$cmnd
        }
        if {$lwt && [regexp {^<.+>[1-9]?$} $topic]} {
            sendMqtt unsub tele $topic LWT $cmnd
        }
        if {[regexp {^.+>[1-9]?$} $topic]} {
            sendMqtt unsub stat $topic pwr $cmnd
        }
        sendMqtt unsub stat $topic rst $cmnd
    }
    mk::row delete cfg.$type!$row

    $win delete [$win selection]
}

# set sort orders from clicked headers
proc cfg_sort {type {dev ext}} {
    global cfg

    if {$type eq "id"} {
        if {$cfg(sortX10) == 1} {
            set cfg(sortX10) -1
        } else {
            set cfg(sortX10) 1
        }
    
    } elseif {$type eq "topic"} {
        set cfg(sortName) 0
        set cfg(sortX10) 0
        if {$cfg(sortTopic) == 1} {
            set cfg(sortTopic) -1
        } else {
            set cfg(sortTopic) 1
        }
    } else {
        set cfg(sortTopic) 0
        set cfg(sortX10) 0
        if {$cfg(sortName) == 1} {
            set cfg(sortName) -1
        } else {
            set cfg(sortName) 1
        }
    }
    cfg_sortlist $dev
}

# Sort device list according to sort orders
proc cfg_sortlist {{type {obj ext}}} {
    foreach t $type {
        cfg_sortlistx $t
    }
}

proc cfg_sortlistx {type} {
    global cfg

    if {[winfo exist .mqtt.usr]} {return}
    if {[winfo exist .mqtt]} {
        if {$type eq "obj"} {
            set device "x10"
            set win .mqtt.f.f3.ni.f.tv
            .mqtt.f.f3.ni.b1 state disabled
            .mqtt.f.f3.ni.b3 state disabled
        } else {
            set device "devices"
            set win .mqtt.f.f1.ni.f.tv
            .mqtt.f.f1.ni.b1 state disabled
            .mqtt.f.f1.ni.b3 state disabled
        }
        if {$cfg(sortX10) != 0} {
            #sort via id field
            if {$cfg(sortX10) == 1} {
                set rows [mk::select cfg.$device -sort {type id}]
            } elseif {$cfg(sortX10) == -1} {
                set rows [mk::select cfg.$device -rsort {type id}]
            }
        } else {
        if {$cfg(sortName) == 0 && $cfg(sortTopic) == 0} {
                set rows [mk::select cfg.$device -globnc topic "*"]
        } elseif {$cfg(sortName) == 1} {
                set rows [mk::select cfg.$device -sort name]
        } elseif {$cfg(sortName) == -1} {
                set rows [mk::select cfg.$device -rsort name]
        } elseif {$cfg(sortTopic) == 1} {
                set rows [mk::select cfg.$device -sort topic]
        } elseif {$cfg(sortTopic) == -1} {
                set rows [mk::select cfg.$device -rsort topic]
        }
        }
        $win delete [$win children {}]
        foreach row $rows {
                set tag "black"
            if {$type in "ext"} {
                if {[mk::get cfg.$device!$row status] == 1} {
                    set tag "red"
                }
                set values [mk::get cfg.$device!$row name topic state]
                set flag [mk::get cfg.$device!$row flag]
                set macro [mk::get cfg.$device!$row macro_on macro_off]
            if {$flag == 512} {
                lappend values "-"
            } else {
                if {$flag > 255} {
                        lappend values VA-[expr {$flag - 256}]
                } else {
                        lappend values FL-$flag
                }
            }
            foreach i [lsearch -all $macro "256"] {
                set macro [lreplace $macro $i $i "-"]
            }
            lappend values [join $macro "/"]
            } elseif {$type in "obj"} {
                set values [mk::get cfg.$device!$row name topic]
                lassign [mk::get cfg.$device!$row id object state] id object state
                if {$object eq "hvac"} {
                    lappend values [lindex {Off Heat Cool Auto} [expr {($state & 0x06)>>1}]]
                } else {
                    lappend values $state
                }
                if {$object eq "x10"} {
                    lappend values [string map {" " -} [hvObjectId x10 $id]]
                } elseif {$object in {input output}} {
                    lappend values [string toupper [string index $object 0]][hvObjectId $object $id]
                } else {
                    lappend values "[string toupper [string range $object 0 1]]-$id"
                }
                lappend values {*}[mk::get cfg.$device!$row type level]
            }
            $win insert {} end -values $values -tags $tag
        }
    }
}

proc cfg_topic_copy {} {
    global mqttname mqtttopic

    set mqttname [string map {" " "" ">" "" "<" ""} $mqtttopic]
    cfg_validate $mqtttopic topic mqttname
}

proc cfg_object_copy {} {
    global mqttname mqtttopic mqttid mqttobj

    if {$mqttid >= 256} {return}

    if {$mqttobj eq "hvac"} {
        set name "Zone $idx"
    } else {
        set name [hvObjectName $mqttobj $mqttid]
    }
    set mqttname [string map {" " _} $name]
    set mqtttopic <[string map {" " ""} $name]>
    cfg_validate $mqtttopic topic mqttname
}

#! Process a flag when selected for a device
proc cfg_flag_set {w} {
    global mqttflag
    
    set c [lindex [split [$w get] ":"] 0]
    if {$c eq "None" || $c eq "-"} {
        set mqttflag 512
    } else {
        lassign [split $c {-}] grp num    
        if {$grp eq "VA"} {
            set mqttflag [expr {$num + 256}]
    } else {
            set mqttflag $num
        }
    }
    cfg_varflag_select
    createflaglist $w
}

#! Create flag list for drop-down box
proc createflaglist {widget} {
    global  mqttflag

    set fcnt [hvObjectCount flag]
    set vcnt [hvObjectCount var]
   
    set val "None"
    for {set v 0; set i 1} {$v < $fcnt} {incr v} {
        set name [hvObjectName flag $v]
        lappend val "FL-$v:$name"
        incr i
    }
    for {set v 0; set i 1} {$v < $vcnt} {incr v} {
        set name [hvObjectName var $v]
        lappend val "VA-$v:$name"
        incr i
    }

    $widget configure -values $val
    if {[llength $val] > 1 && $mqttflag ne "" && $mqttflag < 512} {
        if {$mqttflag < 256} {
        $widget current [expr {$mqttflag + 1}]
    } else {
            $widget current [expr {$mqttflag + $fcnt - 255}]
        }
    } else {
        $widget current 0
        set mqttflag 512
    }
}

#! Process x10 when selected for a device
proc cfg_object_set {w vid vobj} {
    upvar #0 $vid id 
    upvar #0 $vobj object
    
    set c [lindex [split [$w get] ":"] 0]
    if {$c eq "None" || $c eq "-"} {
        set id 256
        set object ""
    } else {
        lassign [split $c {-}] grp num
        if {$grp eq "LI"} {
            set id $num
            set object "light"
        } elseif {$grp eq "FL"} {
            set id $num
            set object "flag"
        } elseif {$grp eq "VA"} {
            set id $num
            set object "var"
        } elseif {$grp eq "HV"} {
            set id $num
            set object "hvac"
        } elseif {$grp eq "TE"} {
            set id $num
            set object "temp"
        } elseif {$grp eq "AN"} {
            set id $num
            set object "analog"
        } elseif {[regexp {^I[A-Q]$} $grp]} {
            set id [getid input [string index $grp 1] $num]
            set object "input"
        } elseif {[regexp {^O[A-Q]$} $grp]} {
            set id [getid output [string index $grp 1] $num]
            set object "output"
        } else {
        set id [expr {(([scan $grp %c] - 65)*16) + $num - 1}]
            set object "x10"
    }
    }
    createobjlist $w $object
    cfg_object_varflag_select
}

proc getid {type grp num} {
    set max 8
    if {$type eq "x10"} {set max 16}
    if {$num < 1 || $num > $max} {return -1}
    set cnt [hvObjectCount $type]
    set i 0
    while {$cnt > $i} {
	if {[string tolower [string index [hvObjectId $type $i] 0]] \
	 eq [string tolower $grp]} {
	    return [expr {$i + $num - 1}]
	}
	incr i $max
    }
    return -1
}

#! Create hv object list for drop-down box
proc createobjlist {widget {object ""}} {
    global  mqttid mqttobj x10types objlist cfg

    set offset 1
    set cnt 0
    unset -nocomplain objlist
    set val "None"
    if {$cfg(x10Enable) || $object eq "x10"} {
        dict set objlist x10 offset $offset    
    set cnt [hvObjectCount x10]
        dict set objlist x10 count $cnt
    for {set v 0; set i 1} {$v < $cnt} {incr v} {
            lappend val "[string map {" " -} [hvObjectId x10 $v]]:[hvObjectName x10 $v]"
        incr i
    }
    }
    foreach obj {light flag var hvac temp analog} {
        if {$cfg(${obj}Enable) || $object eq $obj} {  
            set offset [expr {$offset + $cnt}]  
            dict set objlist $obj offset $offset
            set cnt [hvObjectCount $obj]   
            dict set objlist $obj count $cnt
            for {set v 0; set i 1} {$v < $cnt} {incr v} {
                if {$obj eq "hvac"} {
                    lappend val "[string toupper [string range $obj 0 1]]-$i:Zone $i"
                } else {
                    lappend val "[string toupper [string range $obj 0 1]]-$v:[hvObjectName $obj $v]"
                }
                incr i
            }
        }
    }
    
    foreach obj {input output} {
        if {$cfg(${obj}Enable) || $object eq $obj} {  
            set offset [expr {$offset + $cnt}]  
            dict set objlist $obj offset $offset
            set cnt [hvObjectCount $obj]   
            dict set objlist $obj count $cnt
            for {set v 0; set i 1} {$v < $cnt} {incr v} {
                lappend val "[string toupper [string index $obj 0]][hvObjectId $obj $v]:[hvObjectName $obj $v]"
                incr i
            }
        }
    }
    $widget configure -values $val
    if {[llength $val] > 1 && $mqttid ne "" && $mqttid < 256} {
            if {$mqttobj eq "x10"} {
            set idx [expr {$mqttid + 1}]
            .mqtt.usr.c3 state !disabled
            } elseif {$mqttobj eq "hvac"} {
            set idx [expr {$mqttid - 1 + [dict get $objlist $mqttobj offset]}]
            .mqtt.usr.c3 current 0
            .mqtt.usr.c3 state disabled
            } else {
            set idx [expr {$mqttid + [dict get $objlist $mqttobj offset]}]
            .mqtt.usr.c3 current 0
            .mqtt.usr.c3 state disabled
            }
        if {$mqttobj eq "light"} {
            .mqtt.usr.c3 current [expr {[lsearch -exact $x10types "light"] / 2}]
        }
        $widget current $idx
    } else {
        $widget current 0
        set mqttid 256
        set mqttobj ""
    }
}

proc cfg_objenable {object} {
# placeholder in case action is needed.
}

#! Process a macro when selected for a device
proc cfg_macro_set {w var} {
    upvar #0 $var macro 
    
    set c [lindex [split [$w get] ":"] 0]
    if {$c eq "None" || $c eq "-"} {
        set macro 256
    } else {
        set macro $c
    }
    createmacrolist $w $var
}
#! Create macro list for drop-down box
proc createmacrolist {widget var} {
    upvar #0 $var macro
    
    set cnt [hvObjectCount macro]
   
    set val "None"
    for {set v 0; set i 1} {$v < $cnt} {incr v} {
        set name [hvObjectName macro $v]
        lappend val "$v:$name"
        incr i
    }

    $widget configure -values $val
    if {[llength $val] > 1 && $macro ne "" && $macro < 256} {
        $widget current [expr {$macro + 1}]
    } else {
        $widget current 0
        set macro 256
    }
}

proc cfg_done {} {
    global cfg
    
    mk::loop row cfg.main {
        array set tmpcfg [mk::get $row name value]
    }
    
    if {$tmpcfg(broker) ne $cfg(broker) || $tmpcfg(brokerPort) ne $cfg(brokerPort) \
        || $tmpcfg(userpass) ne $cfg(userpass) \
        || $tmpcfg(username) ne $cfg(username) \
        || $tmpcfg(password) ne $cfg(password) }  {connect}
    if {$tmpcfg(serPre) ne $cfg(serPre)} {
        hvTrigger $tmpcfg(serPre) {}
        hvTrigger $cfg(serPre) [list mqttserial]
    }
    saveconfig
    subscribe
    destroy .mqtt
}

if {[hvGuiInit]} {
    # Set combobox foreground to gray when disabled
    ttk::style map TCombobox -foreground \
        [list disabled #8c8c8c]

    hvMenu [hvMainMenu Main.plugins Plugins] add command \
      -label "MQTT" -command cfg_mqtt

    if {[hvHelpFile mqtt.hlp]} {
        hvMenu [hvMainMenu Help.plugins Plugins] add command \
          -label "MQTT" -command [list hvHelp index]
    }

    bind all <Key-KP_Enter> {event generate %W <Key-Return>}
}

proc init {} {
    global cfg

    loadconfig
    connect
    cinit
    hvTrigger $cfg(serPre) [list mqttserial]
}

proc cinit {} {
    global connected
    
    after cancel cinit
    if {!$connected} {
        after 2000 cinit
        debug "Not Connected to Controller, waiting" red
        return
    }
    
    debug "Connected to Controller!" red

    subscribe
    devupdate

    #force updates
    foreach object {x10 light flag hvac var analog input output} {
    if {[hvObjectCount $object] > 0} {
            hvEventHook ${object}update [list objupdate $object]
            action $object update
        }
    }
    if {[hvObjectCount temp] > 0} {
        hvEventHook digitaltempupdate [list objupdate $object]
        action $object update
    }
}

proc discinit {} {
    global connected

    debug "Disconnected from Controller!" red
    set connected 0
    subscribe unsub
    cinit
}

# End Configuration section

# Start when HomeVisionXL is ready
hvEventHook connect [list set connected 1]
hvEventHook disconnect discinit
# Reconfigure when a new schedule is opened
hvEventHook ready init 
# Gracefully close MQTT session when exiting
hvEventHook exit disconnect
